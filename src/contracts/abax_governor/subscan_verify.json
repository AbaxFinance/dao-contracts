{
    "contracts":{
        "Cargo.lock":"# This file is automatically @generated by Cargo.\n# It is not intended for manual editing.\nversion = 3\n\n[[package]]\nname = \"abax_governor\"\nversion = \"1.0.0\"\ndependencies = [\n \"ethnum\",\n \"ink\",\n \"parity-scale-codec\",\n \"pendzl\",\n \"scale-info\",\n]\n\n[[package]]\nname = \"aead\"\nversion = \"0.5.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"d122413f284cf2d62fb1b7db97e02edb8cda96d769b16e443a4f6195e35662b0\"\ndependencies = [\n \"crypto-common\",\n \"generic-array\",\n]\n\n[[package]]\nname = \"array-init\"\nversion = \"2.1.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"3d62b7694a562cdf5a74227903507c56ab2cc8bdd1f781ed5cb4cf9c9f810bfc\"\n\n[[package]]\nname = \"arrayref\"\nversion = \"0.3.7\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"6b4930d2cb77ce62f89ee5d5289b4ac049559b1c45539271f5ed4fdc7db34545\"\n\n[[package]]\nname = \"arrayvec\"\nversion = \"0.7.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"96d30a06541fbafbc7f82ed10c06164cfbd2c401138f6addd8404629c4b16711\"\n\n[[package]]\nname = \"autocfg\"\nversion = \"1.1.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"d468802bab17cbc0cc575e9b053f41e72aa36bfa6b7f55e3529ffa43161b97fa\"\n\n[[package]]\nname = \"bitflags\"\nversion = \"1.3.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a\"\n\n[[package]]\nname = \"bitvec\"\nversion = \"1.0.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"1bc2832c24239b0141d5674bb9174f9d68a8b5b3f2753311927c172ca46f7e9c\"\ndependencies = [\n \"funty\",\n \"radium\",\n \"tap\",\n \"wyz\",\n]\n\n[[package]]\nname = \"blake2\"\nversion = \"0.10.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"46502ad458c9a52b69d4d4d32775c788b7a1b85e8bc9d482d92250fc0e3f8efe\"\ndependencies = [\n \"digest\",\n]\n\n[[package]]\nname = \"block-buffer\"\nversion = \"0.10.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"3078c7629b62d3f0439517fa394996acacc5cbc91c5a20d8c658e77abd503a71\"\ndependencies = [\n \"generic-array\",\n]\n\n[[package]]\nname = \"byte-slice-cast\"\nversion = \"1.2.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"c3ac9f8b63eca6fd385229b3675f6cc0dc5c8a5c8a54a59d4f52ffd670d87b0c\"\n\n[[package]]\nname = \"byteorder\"\nversion = \"1.5.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"1fd0f2584146f6f2ef48085050886acf353beff7305ebd1ae69500e27c67f64b\"\n\n[[package]]\nname = \"camino\"\nversion = \"1.1.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"c59e92b5a388f549b863a7bea62612c09f24c8393560709a54558a9abdfb3b9c\"\ndependencies = [\n \"serde\",\n]\n\n[[package]]\nname = \"cargo-platform\"\nversion = \"0.1.7\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"694c8807f2ae16faecc43dc17d74b3eb042482789fd0eb64b39a2e04e087053f\"\ndependencies = [\n \"serde\",\n]\n\n[[package]]\nname = \"cargo_metadata\"\nversion = \"0.13.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"081e3f0755c1f380c2d010481b6fa2e02973586d5f2b24eebb7a2a1d98b143d8\"\ndependencies = [\n \"camino\",\n \"cargo-platform\",\n \"semver 0.11.0\",\n \"semver-parser\",\n \"serde\",\n \"serde_json\",\n]\n\n[[package]]\nname = \"cc\"\nversion = \"1.0.90\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"8cd6604a82acf3039f1144f54b8eb34e91ffba622051189e71b781822d5ee1f5\"\n\n[[package]]\nname = \"cfg-if\"\nversion = \"1.0.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n\n[[package]]\nname = \"const_env\"\nversion = \"0.1.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"3e9e4f72c6e3398ca6da372abd9affd8f89781fe728869bbf986206e9af9627e\"\ndependencies = [\n \"const_env_impl\",\n]\n\n[[package]]\nname = \"const_env_impl\"\nversion = \"0.1.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"3a4f51209740b5e1589e702b3044cdd4562cef41b6da404904192ffffb852d62\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"syn 1.0.109\",\n]\n\n[[package]]\nname = \"const_format\"\nversion = \"0.2.32\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"e3a214c7af3d04997541b18d432afaff4c455e79e2029079647e72fc2bd27673\"\ndependencies = [\n \"const_format_proc_macros\",\n]\n\n[[package]]\nname = \"const_format_proc_macros\"\nversion = \"0.2.32\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"c7f6ff08fd20f4f299298a28e2dfa8a8ba1036e6cd2460ac1de7b425d76f2500\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"unicode-xid\",\n]\n\n[[package]]\nname = \"cpufeatures\"\nversion = \"0.2.12\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"53fe5e26ff1b7aef8bca9c6080520cfb8d9333c7568e1829cef191a9723e5504\"\ndependencies = [\n \"libc\",\n]\n\n[[package]]\nname = \"crypto-common\"\nversion = \"0.1.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"1bfb12502f3fc46cca1bb51ac28df9d618d813cdc3d2f25b9fe775a34af26bb3\"\ndependencies = [\n \"generic-array\",\n \"rand_core\",\n \"typenum\",\n]\n\n[[package]]\nname = \"curve25519-dalek\"\nversion = \"4.1.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"0a677b8922c94e01bdbb12126b0bc852f00447528dee1782229af9c720c3f348\"\ndependencies = [\n \"cfg-if\",\n \"cpufeatures\",\n \"curve25519-dalek-derive\",\n \"digest\",\n \"fiat-crypto\",\n \"platforms\",\n \"rustc_version\",\n \"subtle\",\n \"zeroize\",\n]\n\n[[package]]\nname = \"curve25519-dalek-derive\"\nversion = \"0.1.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"f46882e17999c6cc590af592290432be3bce0428cb0d5f8b6715e4dc7b383eb3\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"syn 2.0.53\",\n]\n\n[[package]]\nname = \"darling\"\nversion = \"0.14.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"7b750cb3417fd1b327431a470f388520309479ab0bf5e323505daf0290cd3850\"\ndependencies = [\n \"darling_core\",\n \"darling_macro\",\n]\n\n[[package]]\nname = \"darling_core\"\nversion = \"0.14.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"109c1ca6e6b7f82cc233a97004ea8ed7ca123a9af07a8230878fcfda9b158bf0\"\ndependencies = [\n \"fnv\",\n \"ident_case\",\n \"proc-macro2\",\n \"quote\",\n \"strsim\",\n \"syn 1.0.109\",\n]\n\n[[package]]\nname = \"darling_macro\"\nversion = \"0.14.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"a4aab4dbc9f7611d8b55048a3a16d2d010c2c8334e46304b40ac1cc14bf3b48e\"\ndependencies = [\n \"darling_core\",\n \"quote\",\n \"syn 1.0.109\",\n]\n\n[[package]]\nname = \"derive_more\"\nversion = \"0.99.17\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"4fb810d30a7c1953f91334de7244731fc3f3c10d7fe163338a35b9f640960321\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"syn 1.0.109\",\n]\n\n[[package]]\nname = \"digest\"\nversion = \"0.10.7\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"9ed9a281f7bc9b7576e61468ba615a66a5c8cfdff42420a70aa82701a3b1e292\"\ndependencies = [\n \"block-buffer\",\n \"crypto-common\",\n \"subtle\",\n]\n\n[[package]]\nname = \"dyn-clone\"\nversion = \"1.0.17\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"0d6ef0072f8a535281e4876be788938b528e9a1d43900b82c2569af7da799125\"\n\n[[package]]\nname = \"either\"\nversion = \"1.10.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"11157ac094ffbdde99aa67b23417ebdd801842852b500e395a45a9c0aac03e4a\"\n\n[[package]]\nname = \"equivalent\"\nversion = \"1.0.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"5443807d6dff69373d433ab9ef5378ad8df50ca6298caf15de6e52e24aaf54d5\"\n\n[[package]]\nname = \"ethnum\"\nversion = \"1.5.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"b90ca2580b73ab6a1f724b76ca11ab632df820fd6040c336200d2c1df7b3c82c\"\n\n[[package]]\nname = \"fiat-crypto\"\nversion = \"0.2.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"1676f435fc1dadde4d03e43f5d62b259e1ce5f40bd4ffb21db2b42ebe59c1382\"\n\n[[package]]\nname = \"fnv\"\nversion = \"1.0.7\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"3f9eec918d3f24069decb9af1554cad7c880e2da24a9afd88aca000531ab82c1\"\n\n[[package]]\nname = \"fs2\"\nversion = \"0.4.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"9564fc758e15025b46aa6643b1b77d047d1a56a1aea6e01002ac0c7026876213\"\ndependencies = [\n \"libc\",\n \"winapi\",\n]\n\n[[package]]\nname = \"funty\"\nversion = \"2.0.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"e6d5a32815ae3f33302d95fdcb2ce17862f8c65363dcfd29360480ba1001fc9c\"\n\n[[package]]\nname = \"generic-array\"\nversion = \"0.14.7\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"85649ca51fd72272d7821adaf274ad91c288277713d9c18820d8499a7ff69e9a\"\ndependencies = [\n \"typenum\",\n \"version_check\",\n]\n\n[[package]]\nname = \"getrandom\"\nversion = \"0.2.12\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"190092ea657667030ac6a35e305e62fc4dd69fd98ac98631e5d3a2b1575a12b5\"\ndependencies = [\n \"cfg-if\",\n \"libc\",\n \"wasi\",\n]\n\n[[package]]\nname = \"getrandom_or_panic\"\nversion = \"0.0.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"6ea1015b5a70616b688dc230cfe50c8af89d972cb132d5a622814d29773b10b9\"\ndependencies = [\n \"rand\",\n \"rand_core\",\n]\n\n[[package]]\nname = \"hashbrown\"\nversion = \"0.14.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"290f1a1d9242c78d09ce40a5e87e7554ee637af1351968159f4952f028f75604\"\n\n[[package]]\nname = \"heck\"\nversion = \"0.3.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"6d621efb26863f0e9924c6ac577e8275e5e6b77455db64ffa6c65c904e9e132c\"\ndependencies = [\n \"unicode-segmentation\",\n]\n\n[[package]]\nname = \"heck\"\nversion = \"0.4.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"95505c38b4572b2d910cecb0281560f54b440a19336cbbcb27bf6ce6adc6f5a8\"\n\n[[package]]\nname = \"hex\"\nversion = \"0.4.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"7f24254aa9a54b5c858eaee2f5bccdb46aaf0e486a595ed5fd8f86ba55232a70\"\n\n[[package]]\nname = \"ident_case\"\nversion = \"1.0.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"b9e0384b61958566e926dc50660321d12159025e767c18e043daf26b70104c39\"\n\n[[package]]\nname = \"impl-serde\"\nversion = \"0.4.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"ebc88fc67028ae3db0c853baa36269d398d5f45b6982f95549ff5def78c935cd\"\ndependencies = [\n \"serde\",\n]\n\n[[package]]\nname = \"impl-trait-for-tuples\"\nversion = \"0.2.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"11d7a9f6330b71fea57921c9b61c47ee6e84f72d394754eff6163ae67e7395eb\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"syn 1.0.109\",\n]\n\n[[package]]\nname = \"indexmap\"\nversion = \"2.2.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"7b0b929d511467233429c45a44ac1dcaa21ba0f5ba11e4879e6ed28ddb4f9df4\"\ndependencies = [\n \"equivalent\",\n \"hashbrown\",\n]\n\n[[package]]\nname = \"ink\"\nversion = \"5.0.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"3d4a862aedbfda93175ddf75c9aaa2ae4c4b39ee5cee06c16d50bccce05bf5c7\"\ndependencies = [\n \"derive_more\",\n \"ink_env\",\n \"ink_macro\",\n \"ink_metadata\",\n \"ink_prelude 5.0.0\",\n \"ink_primitives 5.0.0\",\n \"ink_storage\",\n \"pallet-contracts-uapi-next\",\n \"parity-scale-codec\",\n \"scale-info\",\n]\n\n[[package]]\nname = \"ink_allocator\"\nversion = \"5.0.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"5cee56055bac6d928d425e944c5f3b69baa33c9635822fd1c00cd4afc70fde3e\"\ndependencies = [\n \"cfg-if\",\n]\n\n[[package]]\nname = \"ink_codegen\"\nversion = \"5.0.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"70a1f8473fa09e0f9b6f3cb3f8d18c07c14ebf9ea1f7cdfee270f009d45ee8e9\"\ndependencies = [\n \"blake2\",\n \"derive_more\",\n \"either\",\n \"heck 0.4.1\",\n \"impl-serde\",\n \"ink_ir 5.0.0\",\n \"ink_primitives 5.0.0\",\n \"itertools 0.12.1\",\n \"parity-scale-codec\",\n \"proc-macro2\",\n \"quote\",\n \"serde\",\n \"serde_json\",\n \"syn 2.0.53\",\n]\n\n[[package]]\nname = \"ink_engine\"\nversion = \"5.0.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"4f357e2e867f4e222ffc4015a6e61d1073548de89f70a4e36a8b0385562777fa\"\ndependencies = [\n \"blake2\",\n \"derive_more\",\n \"ink_primitives 5.0.0\",\n \"pallet-contracts-uapi-next\",\n \"parity-scale-codec\",\n \"secp256k1\",\n \"sha2\",\n \"sha3\",\n]\n\n[[package]]\nname = \"ink_env\"\nversion = \"5.0.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"42cec50b7e4f8406aab25801b015d3802a52d76cfbe48ce11cfb4200fa88e296\"\ndependencies = [\n \"blake2\",\n \"cfg-if\",\n \"const_env\",\n \"derive_more\",\n \"ink_allocator\",\n \"ink_engine\",\n \"ink_prelude 5.0.0\",\n \"ink_primitives 5.0.0\",\n \"ink_storage_traits\",\n \"num-traits\",\n \"pallet-contracts-uapi-next\",\n \"parity-scale-codec\",\n \"paste\",\n \"rlibc\",\n \"scale-decode\",\n \"scale-encode\",\n \"scale-info\",\n \"schnorrkel\",\n \"secp256k1\",\n \"sha2\",\n \"sha3\",\n \"static_assertions\",\n]\n\n[[package]]\nname = \"ink_ir\"\nversion = \"4.3.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"5b529c941518e8f450395fab9fe8ebba0a7acbb18778fc7e0a87f6248286ec72\"\ndependencies = [\n \"blake2\",\n \"either\",\n \"itertools 0.10.5\",\n \"proc-macro2\",\n \"quote\",\n \"syn 2.0.53\",\n]\n\n[[package]]\nname = \"ink_ir\"\nversion = \"5.0.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"3b1ad2975551c4ed800af971289ed6d2c68ac41ffc03a42010b3e01d7360dfb2\"\ndependencies = [\n \"blake2\",\n \"either\",\n \"impl-serde\",\n \"ink_prelude 5.0.0\",\n \"itertools 0.12.1\",\n \"proc-macro2\",\n \"quote\",\n \"syn 2.0.53\",\n]\n\n[[package]]\nname = \"ink_macro\"\nversion = \"5.0.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"aee1a546f37eae3b3cd223832d31702033c5369dcfa3405899587c110a7908d3\"\ndependencies = [\n \"ink_codegen\",\n \"ink_ir 5.0.0\",\n \"ink_primitives 5.0.0\",\n \"parity-scale-codec\",\n \"proc-macro2\",\n \"quote\",\n \"syn 2.0.53\",\n \"synstructure 0.13.1\",\n]\n\n[[package]]\nname = \"ink_metadata\"\nversion = \"5.0.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"a98fcc0ff9292ff68c7ee7b84c93533c9ff13859ec3b148faa822e2da9954fe6\"\ndependencies = [\n \"derive_more\",\n \"impl-serde\",\n \"ink_prelude 5.0.0\",\n \"ink_primitives 5.0.0\",\n \"linkme\",\n \"parity-scale-codec\",\n \"scale-info\",\n \"schemars\",\n \"serde\",\n]\n\n[[package]]\nname = \"ink_prelude\"\nversion = \"4.3.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"d8cfdf91d2b442f08efb34dd3780fd6fbd3d033f63b42f62684fe47534948ef6\"\ndependencies = [\n \"cfg-if\",\n]\n\n[[package]]\nname = \"ink_prelude\"\nversion = \"5.0.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"ea1734d058c80aa72e59c8ae75624fd8a51791efba21469f273156c0f4cad5c9\"\ndependencies = [\n \"cfg-if\",\n]\n\n[[package]]\nname = \"ink_primitives\"\nversion = \"4.3.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"6414bcad12ebf0c3abbbb192a09e4d06e22f662cf3e19545204e1b0684be12a1\"\ndependencies = [\n \"derive_more\",\n \"ink_prelude 4.3.0\",\n \"parity-scale-codec\",\n \"xxhash-rust\",\n]\n\n[[package]]\nname = \"ink_primitives\"\nversion = \"5.0.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"11ec35ef7f45e67a53b6142d7e7f18e6d9292d76c3a2a1da14cf8423e481813d\"\ndependencies = [\n \"derive_more\",\n \"ink_prelude 5.0.0\",\n \"parity-scale-codec\",\n \"scale-decode\",\n \"scale-encode\",\n \"scale-info\",\n \"xxhash-rust\",\n]\n\n[[package]]\nname = \"ink_storage\"\nversion = \"5.0.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"bbdb04cad74df858c05bc9cb6f30bbf12da33c3e2cb7ca211749c001fa761aa9\"\ndependencies = [\n \"array-init\",\n \"cfg-if\",\n \"derive_more\",\n \"ink_env\",\n \"ink_metadata\",\n \"ink_prelude 5.0.0\",\n \"ink_primitives 5.0.0\",\n \"ink_storage_traits\",\n \"pallet-contracts-uapi-next\",\n \"parity-scale-codec\",\n \"scale-info\",\n]\n\n[[package]]\nname = \"ink_storage_traits\"\nversion = \"5.0.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"83ce49e3d2935fc1ec3e73117119712b187d3123339f6a31624e92f75fa2293d\"\ndependencies = [\n \"ink_metadata\",\n \"ink_prelude 5.0.0\",\n \"ink_primitives 5.0.0\",\n \"parity-scale-codec\",\n \"scale-info\",\n]\n\n[[package]]\nname = \"itertools\"\nversion = \"0.10.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"b0fd2260e829bddf4cb6ea802289de2f86d6a7a690192fbe91b3f46e0f2c8473\"\ndependencies = [\n \"either\",\n]\n\n[[package]]\nname = \"itertools\"\nversion = \"0.12.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"ba291022dbbd398a455acf126c1e341954079855bc60dfdda641363bd6922569\"\ndependencies = [\n \"either\",\n]\n\n[[package]]\nname = \"itoa\"\nversion = \"1.0.10\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"b1a46d1a171d865aa5f83f92695765caa047a9b4cbae2cbf37dbd613a793fd4c\"\n\n[[package]]\nname = \"keccak\"\nversion = \"0.1.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"ecc2af9a1119c51f12a14607e783cb977bde58bc069ff0c3da1095e635d70654\"\ndependencies = [\n \"cpufeatures\",\n]\n\n[[package]]\nname = \"libc\"\nversion = \"0.2.153\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"9c198f91728a82281a64e1f4f9eeb25d82cb32a5de251c6bd1b5154d63a8e7bd\"\n\n[[package]]\nname = \"linkme\"\nversion = \"0.3.25\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"bb2cfee0de9bd869589fb9a015e155946d1be5ff415cb844c2caccc6cc4b5db9\"\ndependencies = [\n \"linkme-impl\",\n]\n\n[[package]]\nname = \"linkme-impl\"\nversion = \"0.3.25\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"adf157a4dc5a29b7b464aa8fe7edeff30076e07e13646a1c3874f58477dc99f8\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"syn 2.0.53\",\n]\n\n[[package]]\nname = \"memchr\"\nversion = \"2.7.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"523dc4f511e55ab87b694dc30d0f820d60906ef06413f93d4d7a1385599cc149\"\n\n[[package]]\nname = \"merlin\"\nversion = \"3.0.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"58c38e2799fc0978b65dfff8023ec7843e2330bb462f19198840b34b6582397d\"\ndependencies = [\n \"byteorder\",\n \"keccak\",\n \"rand_core\",\n \"zeroize\",\n]\n\n[[package]]\nname = \"num-traits\"\nversion = \"0.2.18\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"da0df0e5185db44f69b44f26786fe401b6c293d1907744beaa7fa62b2e5a517a\"\ndependencies = [\n \"autocfg\",\n]\n\n[[package]]\nname = \"once_cell\"\nversion = \"1.19.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"3fdb12b2476b595f9358c5161aa467c2438859caa136dec86c26fdd2efe17b92\"\n\n[[package]]\nname = \"pallet-contracts-uapi-next\"\nversion = \"6.0.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"fd549c16296ea5b2eb7c65c56aba548b286c1be4d7675b424ff6ccb8319c97a9\"\ndependencies = [\n \"bitflags\",\n \"paste\",\n \"polkavm-derive\",\n]\n\n[[package]]\nname = \"parity-scale-codec\"\nversion = \"3.6.9\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"881331e34fa842a2fb61cc2db9643a8fedc615e47cfcc52597d1af0db9a7e8fe\"\ndependencies = [\n \"arrayvec\",\n \"bitvec\",\n \"byte-slice-cast\",\n \"impl-trait-for-tuples\",\n \"parity-scale-codec-derive\",\n \"serde\",\n]\n\n[[package]]\nname = \"parity-scale-codec-derive\"\nversion = \"3.6.9\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"be30eaf4b0a9fba5336683b38de57bb86d179a35862ba6bfcf57625d006bde5b\"\ndependencies = [\n \"proc-macro-crate 2.0.2\",\n \"proc-macro2\",\n \"quote\",\n \"syn 1.0.109\",\n]\n\n[[package]]\nname = \"paste\"\nversion = \"1.0.14\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"de3145af08024dea9fa9914f381a17b8fc6034dfb00f3a84013f7ff43f29ed4c\"\n\n[[package]]\nname = \"pendzl\"\nversion = \"1.0.1-v1calls\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"7c79ba487736e2475e44ec917040cd87dc4ba9f27fddb8c95f4bf130b4ac6a65\"\ndependencies = [\n \"ink\",\n \"parity-scale-codec\",\n \"pendzl_contracts\",\n \"pendzl_lang\",\n \"scale-info\",\n]\n\n[[package]]\nname = \"pendzl_contracts\"\nversion = \"1.0.1-v1calls\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"ab692839aad45923200968ff94a3c64595f6a17f1059ae3d0e363a80a4837699\"\ndependencies = [\n \"hex\",\n \"ink\",\n \"parity-scale-codec\",\n \"pendzl_lang\",\n \"scale-info\",\n]\n\n[[package]]\nname = \"pendzl_lang\"\nversion = \"1.0.1-v1calls\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"df579ab11b77f1efacff5f4dea408927c264ad903de994b929206f3885832be7\"\ndependencies = [\n \"const_format\",\n \"ethnum\",\n \"ink\",\n \"parity-scale-codec\",\n \"pendzl_lang_macro\",\n \"scale-info\",\n \"xxhash-rust\",\n]\n\n[[package]]\nname = \"pendzl_lang_codegen\"\nversion = \"1.0.1-v1calls\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"3217fddc39db986a85aff5da5448bd2d6c296d93e51a8d267cbe26cb47f8dc5e\"\ndependencies = [\n \"blake2\",\n \"cargo_metadata\",\n \"fs2\",\n \"heck 0.3.3\",\n \"ink_ir 4.3.0\",\n \"ink_primitives 4.3.0\",\n \"proc-macro2\",\n \"quote\",\n \"serde\",\n \"serde_json\",\n \"syn 1.0.109\",\n \"synstructure 0.12.6\",\n \"unwrap\",\n]\n\n[[package]]\nname = \"pendzl_lang_macro\"\nversion = \"1.0.1-v1calls\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"680746c3225b7b0fadd7aa78a6fca44589ba16591a6a6889488110f5033888eb\"\ndependencies = [\n \"pendzl_lang_codegen\",\n \"proc-macro2\",\n \"syn 1.0.109\",\n \"synstructure 0.12.6\",\n]\n\n[[package]]\nname = \"pest\"\nversion = \"2.7.8\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"56f8023d0fb78c8e03784ea1c7f3fa36e68a723138990b8d5a47d916b651e7a8\"\ndependencies = [\n \"memchr\",\n \"thiserror\",\n \"ucd-trie\",\n]\n\n[[package]]\nname = \"platforms\"\nversion = \"3.3.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"626dec3cac7cc0e1577a2ec3fc496277ec2baa084bebad95bb6fdbfae235f84c\"\n\n[[package]]\nname = \"polkavm-common\"\nversion = \"0.5.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"88b4e215c80fe876147f3d58158d5dfeae7dabdd6047e175af77095b78d0035c\"\n\n[[package]]\nname = \"polkavm-derive\"\nversion = \"0.5.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"6380dbe1fb03ecc74ad55d841cfc75480222d153ba69ddcb00977866cbdabdb8\"\ndependencies = [\n \"polkavm-derive-impl\",\n \"syn 2.0.53\",\n]\n\n[[package]]\nname = \"polkavm-derive-impl\"\nversion = \"0.5.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"dc8211b3365bbafb2fb32057d68b0e1ca55d079f5cf6f9da9b98079b94b3987d\"\ndependencies = [\n \"polkavm-common\",\n \"proc-macro2\",\n \"quote\",\n \"syn 2.0.53\",\n]\n\n[[package]]\nname = \"ppv-lite86\"\nversion = \"0.2.17\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"5b40af805b3121feab8a3c29f04d8ad262fa8e0561883e7653e024ae4479e6de\"\n\n[[package]]\nname = \"proc-macro-crate\"\nversion = \"1.3.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"7f4c021e1093a56626774e81216a4ce732a735e5bad4868a03f3ed65ca0c3919\"\ndependencies = [\n \"once_cell\",\n \"toml_edit 0.19.15\",\n]\n\n[[package]]\nname = \"proc-macro-crate\"\nversion = \"2.0.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"b00f26d3400549137f92511a46ac1cd8ce37cb5598a96d382381458b992a5d24\"\ndependencies = [\n \"toml_datetime\",\n \"toml_edit 0.20.2\",\n]\n\n[[package]]\nname = \"proc-macro2\"\nversion = \"1.0.79\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"e835ff2298f5721608eb1a980ecaee1aef2c132bf95ecc026a11b7bf3c01c02e\"\ndependencies = [\n \"unicode-ident\",\n]\n\n[[package]]\nname = \"quote\"\nversion = \"1.0.35\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"291ec9ab5efd934aaf503a6466c5d5251535d108ee747472c3977cc5acc868ef\"\ndependencies = [\n \"proc-macro2\",\n]\n\n[[package]]\nname = \"radium\"\nversion = \"0.7.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"dc33ff2d4973d518d823d61aa239014831e521c75da58e3df4840d3f47749d09\"\n\n[[package]]\nname = \"rand\"\nversion = \"0.8.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"34af8d1a0e25924bc5b7c43c079c942339d8f0a8b57c39049bef581b46327404\"\ndependencies = [\n \"libc\",\n \"rand_chacha\",\n \"rand_core\",\n]\n\n[[package]]\nname = \"rand_chacha\"\nversion = \"0.3.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"e6c10a63a0fa32252be49d21e7709d4d4baf8d231c2dbce1eaa8141b9b127d88\"\ndependencies = [\n \"ppv-lite86\",\n \"rand_core\",\n]\n\n[[package]]\nname = \"rand_core\"\nversion = \"0.6.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"ec0be4795e2f6a28069bec0b5ff3e2ac9bafc99e6a9a7dc3547996c5c816922c\"\ndependencies = [\n \"getrandom\",\n]\n\n[[package]]\nname = \"rlibc\"\nversion = \"1.0.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"fc874b127765f014d792f16763a81245ab80500e2ad921ed4ee9e82481ee08fe\"\n\n[[package]]\nname = \"rustc_version\"\nversion = \"0.4.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"bfa0f585226d2e68097d4f95d113b15b83a82e819ab25717ec0590d9584ef366\"\ndependencies = [\n \"semver 1.0.22\",\n]\n\n[[package]]\nname = \"ryu\"\nversion = \"1.0.17\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"e86697c916019a8588c99b5fac3cead74ec0b4b819707a682fd4d23fa0ce1ba1\"\n\n[[package]]\nname = \"scale-bits\"\nversion = \"0.4.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"036575c29af9b6e4866ffb7fa055dbf623fe7a9cc159b33786de6013a6969d89\"\ndependencies = [\n \"parity-scale-codec\",\n \"scale-info\",\n]\n\n[[package]]\nname = \"scale-decode\"\nversion = \"0.10.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"7caaf753f8ed1ab4752c6afb20174f03598c664724e0e32628e161c21000ff76\"\ndependencies = [\n \"derive_more\",\n \"parity-scale-codec\",\n \"scale-bits\",\n \"scale-decode-derive\",\n \"scale-info\",\n \"smallvec\",\n]\n\n[[package]]\nname = \"scale-decode-derive\"\nversion = \"0.10.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"d3475108a1b62c7efd1b5c65974f30109a598b2f45f23c9ae030acb9686966db\"\ndependencies = [\n \"darling\",\n \"proc-macro-crate 1.3.1\",\n \"proc-macro2\",\n \"quote\",\n \"syn 1.0.109\",\n]\n\n[[package]]\nname = \"scale-encode\"\nversion = \"0.5.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"6d70cb4b29360105483fac1ed567ff95d65224a14dd275b6303ed0a654c78de5\"\ndependencies = [\n \"derive_more\",\n \"parity-scale-codec\",\n \"scale-encode-derive\",\n \"scale-info\",\n \"smallvec\",\n]\n\n[[package]]\nname = \"scale-encode-derive\"\nversion = \"0.5.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"995491f110efdc6bea96d6a746140e32bfceb4ea47510750a5467295a4707a25\"\ndependencies = [\n \"darling\",\n \"proc-macro-crate 1.3.1\",\n \"proc-macro2\",\n \"quote\",\n \"syn 1.0.109\",\n]\n\n[[package]]\nname = \"scale-info\"\nversion = \"2.11.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"2ef2175c2907e7c8bc0a9c3f86aeb5ec1f3b275300ad58a44d0c3ae379a5e52e\"\ndependencies = [\n \"bitvec\",\n \"cfg-if\",\n \"derive_more\",\n \"parity-scale-codec\",\n \"scale-info-derive\",\n \"schemars\",\n \"serde\",\n]\n\n[[package]]\nname = \"scale-info-derive\"\nversion = \"2.11.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"634d9b8eb8fd61c5cdd3390d9b2132300a7e7618955b98b8416f118c1b4e144f\"\ndependencies = [\n \"proc-macro-crate 1.3.1\",\n \"proc-macro2\",\n \"quote\",\n \"syn 1.0.109\",\n]\n\n[[package]]\nname = \"schemars\"\nversion = \"0.8.16\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"45a28f4c49489add4ce10783f7911893516f15afe45d015608d41faca6bc4d29\"\ndependencies = [\n \"dyn-clone\",\n \"schemars_derive\",\n \"serde\",\n \"serde_json\",\n]\n\n[[package]]\nname = \"schemars_derive\"\nversion = \"0.8.16\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"c767fd6fa65d9ccf9cf026122c1b555f2ef9a4f0cea69da4d7dbc3e258d30967\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"serde_derive_internals\",\n \"syn 1.0.109\",\n]\n\n[[package]]\nname = \"schnorrkel\"\nversion = \"0.11.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"8de18f6d8ba0aad7045f5feae07ec29899c1112584a38509a84ad7b04451eaa0\"\ndependencies = [\n \"aead\",\n \"arrayref\",\n \"arrayvec\",\n \"curve25519-dalek\",\n \"getrandom_or_panic\",\n \"merlin\",\n \"rand_core\",\n \"serde_bytes\",\n \"sha2\",\n \"subtle\",\n \"zeroize\",\n]\n\n[[package]]\nname = \"secp256k1\"\nversion = \"0.28.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"d24b59d129cdadea20aea4fb2352fa053712e5d713eee47d700cd4b2bc002f10\"\ndependencies = [\n \"secp256k1-sys\",\n]\n\n[[package]]\nname = \"secp256k1-sys\"\nversion = \"0.9.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"e5d1746aae42c19d583c3c1a8c646bfad910498e2051c551a7f2e3c0c9fbb7eb\"\ndependencies = [\n \"cc\",\n]\n\n[[package]]\nname = \"semver\"\nversion = \"0.11.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"f301af10236f6df4160f7c3f04eec6dbc70ace82d23326abad5edee88801c6b6\"\ndependencies = [\n \"semver-parser\",\n \"serde\",\n]\n\n[[package]]\nname = \"semver\"\nversion = \"1.0.22\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"92d43fe69e652f3df9bdc2b85b2854a0825b86e4fb76bc44d945137d053639ca\"\n\n[[package]]\nname = \"semver-parser\"\nversion = \"0.10.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"00b0bef5b7f9e0df16536d3961cfb6e84331c065b4066afb39768d0e319411f7\"\ndependencies = [\n \"pest\",\n]\n\n[[package]]\nname = \"serde\"\nversion = \"1.0.197\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"3fb1c873e1b9b056a4dc4c0c198b24c3ffa059243875552b2bd0933b1aee4ce2\"\ndependencies = [\n \"serde_derive\",\n]\n\n[[package]]\nname = \"serde_bytes\"\nversion = \"0.11.14\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"8b8497c313fd43ab992087548117643f6fcd935cbf36f176ffda0aacf9591734\"\ndependencies = [\n \"serde\",\n]\n\n[[package]]\nname = \"serde_derive\"\nversion = \"1.0.197\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"7eb0b34b42edc17f6b7cac84a52a1c5f0e1bb2227e997ca9011ea3dd34e8610b\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"syn 2.0.53\",\n]\n\n[[package]]\nname = \"serde_derive_internals\"\nversion = \"0.26.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"85bf8229e7920a9f636479437026331ce11aa132b4dde37d121944a44d6e5f3c\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"syn 1.0.109\",\n]\n\n[[package]]\nname = \"serde_json\"\nversion = \"1.0.114\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"c5f09b1bd632ef549eaa9f60a1f8de742bdbc698e6cee2095fc84dde5f549ae0\"\ndependencies = [\n \"itoa\",\n \"ryu\",\n \"serde\",\n]\n\n[[package]]\nname = \"sha2\"\nversion = \"0.10.8\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"793db75ad2bcafc3ffa7c68b215fee268f537982cd901d132f89c6343f3a3dc8\"\ndependencies = [\n \"cfg-if\",\n \"cpufeatures\",\n \"digest\",\n]\n\n[[package]]\nname = \"sha3\"\nversion = \"0.10.8\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"75872d278a8f37ef87fa0ddbda7802605cb18344497949862c0d4dcb291eba60\"\ndependencies = [\n \"digest\",\n \"keccak\",\n]\n\n[[package]]\nname = \"smallvec\"\nversion = \"1.13.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"e6ecd384b10a64542d77071bd64bd7b231f4ed5940fba55e98c3de13824cf3d7\"\n\n[[package]]\nname = \"static_assertions\"\nversion = \"1.1.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"a2eb9349b6444b326872e140eb1cf5e7c522154d69e7a0ffb0fb81c06b37543f\"\n\n[[package]]\nname = \"strsim\"\nversion = \"0.10.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"73473c0e59e6d5812c5dfe2a064a6444949f089e20eec9a2e5506596494e4623\"\n\n[[package]]\nname = \"subtle\"\nversion = \"2.5.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"81cdd64d312baedb58e21336b31bc043b77e01cc99033ce76ef539f78e965ebc\"\n\n[[package]]\nname = \"syn\"\nversion = \"1.0.109\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"72b64191b275b66ffe2469e8af2c1cfe3bafa67b529ead792a6d0160888b4237\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"unicode-ident\",\n]\n\n[[package]]\nname = \"syn\"\nversion = \"2.0.53\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"7383cd0e49fff4b6b90ca5670bfd3e9d6a733b3f90c686605aa7eec8c4996032\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"unicode-ident\",\n]\n\n[[package]]\nname = \"synstructure\"\nversion = \"0.12.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"f36bdaa60a83aca3921b5259d5400cbf5e90fc51931376a9bd4a0eb79aa7210f\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"syn 1.0.109\",\n \"unicode-xid\",\n]\n\n[[package]]\nname = \"synstructure\"\nversion = \"0.13.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"c8af7666ab7b6390ab78131fb5b0fce11d6b7a6951602017c35fa82800708971\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"syn 2.0.53\",\n]\n\n[[package]]\nname = \"tap\"\nversion = \"1.0.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"55937e1799185b12863d447f42597ed69d9928686b8d88a1df17376a097d8369\"\n\n[[package]]\nname = \"thiserror\"\nversion = \"1.0.58\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"03468839009160513471e86a034bb2c5c0e4baae3b43f79ffc55c4a5427b3297\"\ndependencies = [\n \"thiserror-impl\",\n]\n\n[[package]]\nname = \"thiserror-impl\"\nversion = \"1.0.58\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"c61f3ba182994efc43764a46c018c347bc492c79f024e705f46567b418f6d4f7\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"syn 2.0.53\",\n]\n\n[[package]]\nname = \"toml_datetime\"\nversion = \"0.6.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"7cda73e2f1397b1262d6dfdcef8aafae14d1de7748d66822d3bfeeb6d03e5e4b\"\n\n[[package]]\nname = \"toml_edit\"\nversion = \"0.19.15\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"1b5bb770da30e5cbfde35a2d7b9b8a2c4b8ef89548a7a6aeab5c9a576e3e7421\"\ndependencies = [\n \"indexmap\",\n \"toml_datetime\",\n \"winnow\",\n]\n\n[[package]]\nname = \"toml_edit\"\nversion = \"0.20.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"396e4d48bbb2b7554c944bde63101b5ae446cff6ec4a24227428f15eb72ef338\"\ndependencies = [\n \"indexmap\",\n \"toml_datetime\",\n \"winnow\",\n]\n\n[[package]]\nname = \"typenum\"\nversion = \"1.17.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"42ff0bf0c66b8238c6f3b578df37d0b7848e55df8577b3f74f92a69acceeb825\"\n\n[[package]]\nname = \"ucd-trie\"\nversion = \"0.1.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"ed646292ffc8188ef8ea4d1e0e0150fb15a5c2e12ad9b8fc191ae7a8a7f3c4b9\"\n\n[[package]]\nname = \"unicode-ident\"\nversion = \"1.0.12\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"3354b9ac3fae1ff6755cb6db53683adb661634f67557942dea4facebec0fee4b\"\n\n[[package]]\nname = \"unicode-segmentation\"\nversion = \"1.11.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"d4c87d22b6e3f4a18d4d40ef354e97c90fcb14dd91d7dc0aa9d8a1172ebf7202\"\n\n[[package]]\nname = \"unicode-xid\"\nversion = \"0.2.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"f962df74c8c05a667b5ee8bcf162993134c104e96440b663c8daa176dc772d8c\"\n\n[[package]]\nname = \"unwrap\"\nversion = \"1.2.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"7e33648dd74328e622c7be51f3b40a303c63f93e6fa5f08778b6203a4c25c20f\"\n\n[[package]]\nname = \"version_check\"\nversion = \"0.9.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"49874b5167b65d7193b8aba1567f5c7d93d001cafc34600cee003eda787e483f\"\n\n[[package]]\nname = \"wasi\"\nversion = \"0.11.0+wasi-snapshot-preview1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"9c8d87e72b64a3b4db28d11ce29237c246188f4f51057d65a7eab63b7987e423\"\n\n[[package]]\nname = \"winapi\"\nversion = \"0.3.9\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"5c839a674fcd7a98952e593242ea400abe93992746761e38641405d28b00f419\"\ndependencies = [\n \"winapi-i686-pc-windows-gnu\",\n \"winapi-x86_64-pc-windows-gnu\",\n]\n\n[[package]]\nname = \"winapi-i686-pc-windows-gnu\"\nversion = \"0.4.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6\"\n\n[[package]]\nname = \"winapi-x86_64-pc-windows-gnu\"\nversion = \"0.4.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f\"\n\n[[package]]\nname = \"winnow\"\nversion = \"0.5.40\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"f593a95398737aeed53e489c785df13f3618e41dbcd6718c6addbf1395aa6876\"\ndependencies = [\n \"memchr\",\n]\n\n[[package]]\nname = \"wyz\"\nversion = \"0.5.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"05f360fc0b24296329c78fda852a1e9ae82de9cf7b27dae4b7f62f118f77b9ed\"\ndependencies = [\n \"tap\",\n]\n\n[[package]]\nname = \"xxhash-rust\"\nversion = \"0.8.10\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"927da81e25be1e1a2901d59b81b37dd2efd1fc9c9345a55007f09bf5a2d3ee03\"\n\n[[package]]\nname = \"zeroize\"\nversion = \"1.7.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"525b4ec142c6b68a2d10f01f7bbf6755599ca3f81ea53b8431b7dd348f5fdb2d\"\ndependencies = [\n \"zeroize_derive\",\n]\n\n[[package]]\nname = \"zeroize_derive\"\nversion = \"1.4.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"ce36e65b0d2999d2aafac989fb249189a141aee1f53c612c1f37d72631959f69\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"syn 2.0.53\",\n]\n",
        "Cargo.toml":"[package]\nname = \"abax_governor\"\nversion = \"1.0.0\"\nauthors = [\"[your_name] <[your_email]>\"]\nedition = \"2021\"\n\n[dependencies]\nscale = { package = \"parity-scale-codec\", version = \"3.6.9\", default-features = false, features = [\n    \"derive\",\n    \"chain-error\",\n] }\nink = { version = \"5.0.0\", default-features = false }\nscale-info = { version = \"2.11\", default-features = false, features = [\n    \"derive\",\n], optional = true }\n\npendzl = { version = \"=1.0.1-v1calls\", default-features = false, features = [\n    \"psp22_impl\",\n    \"psp22_vault_impl\",\n    \"psp22_metadata_impl\",\n    \"access_control_impl\",\n    \"general_vest_impl\",\n    \"provide_vest_schedule_info\",\n    \"set_code_hash_impl\",\n] }\n\nethnum = { version = \"1.5\", default-features = false }\n\n\n[dev-dependencies]\n\n[lib]\npath = \"lib.rs\"\n\n[features]\ndefault = [\"std\"]\nstd = [\"ink/std\", \"scale/std\", \"scale-info/std\", \"pendzl/std\"]\nink-as-dependency = []\ne2e-tests = []\n\n[profile.dev]\ncodegen-units = 16\npanic = \"abort\"\nlto = false\n[profile.release]\npanic = \"abort\"\nlto = false\n",
        "lib.rs":"#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\nmod modules;\n/// This is AbaxGovernor Contract implementation.\n/// It allows for staking PSP22 token (Abax token) in exchange for PSP22Vault shares (votes).\n/// The shares are non-transferrable.\n/// Withdrawing assets is possible only after unstake period - unstaking is handled by GeneralVest contract.\n///\n/// The contract allows for proposing and voting on proposals by implementing Govern trait.\n/// To create a proposal, the proposer must have enough votes (shares) to meet the minimum stake part.\n/// While proposal is created the proposer must deposit a part of his votes. This votes are returned when proposal is finalized unless the proposal is finalized with 'DefeatedWithSlash' status.\n/// One share is one vote.\n/// Proposal has 3 periods of voting: Intial, Flat and Final which influence the minimum votes to finalize.\n/// If proposal was finalized in Final phase, it's possible to force unstake an account that didn't vote on that proposal.\n///\n/// Contract is using pendzl Access Control to manage access to the messages\n\n#[pendzl::implementation(PSP22, PSP22Vault, PSP22Metadata, AccessControl, SetCodeHash)]\n#[ink::contract]\nmod abax_governor {\n    pub use crate::modules::govern::{\n        helpers::{\n            finalization::minimum_to_finalize,\n            hashes::{hash_description, hash_proposal},\n        },\n        storage::{\n            govern_storage_item::GovernData, locked_shares_storage_item::LockedSharesData,\n            unstake_storage_item::UnstakeData, vault_counter_storage_item::VaultCounterData,\n        },\n        traits::{\n            AbaxGovern, AbaxGovernInternal, AbaxGovernManage, AbaxGovernView, GovernError,\n            OpaqueTypes, Proposal, ProposalCreated, ProposalExecuted, ProposalFinalized,\n            ProposalHash, ProposalId, ProposalState, ProposalStatus, UnstakePeriodChanged,\n            UserVote, Vote, VoteCasted, VotingRules, VotingRulesChanged,\n        },\n    };\n    use ink::codegen::TraitCallBuilder;\n    pub use ink::{\n        codegen::Env,\n        env::DefaultEnvironment,\n        prelude::string::{String, ToString},\n        ToAccountId,\n    };\n\n    pub use pendzl::{\n        contracts::{\n            access_control::RoleType,\n            general_vest::{\n                ExternalTimeConstraint, GeneralVest, ProvideVestScheduleInfo, VestingSchedule,\n            },\n            psp22::{vault::PSP22VaultInternalDefaultImpl, *},\n        },\n        math::operations::mul_div,\n        traits::Flush,\n    };\n\n    pub const EXECUTOR: RoleType = ink::selector_id!(\"EXECUTOR\");\n    pub const PARAMETERS_ADMIN: RoleType = ink::selector_id!(\"PARAMETERS_ADMIN\"); // 368_001_360_u32\n\n    #[derive(StorageFieldGetter)]\n    #[ink(storage)]\n    pub struct AbaxGovernor {\n        // pendzl storage fields\n        #[storage_field]\n        access_control: AccessControlData,\n        #[storage_field]\n        psp22: PSP22Data,\n        #[storage_field]\n        vault: PSP22VaultData,\n        #[storage_field]\n        metadata: PSP22MetadataData,\n        // non-pendzl storage fields\n        #[storage_field]\n        govern: GovernData,\n        #[storage_field]\n        counter: VaultCounterData,\n        #[storage_field]\n        lock: LockedSharesData,\n        #[storage_field]\n        unstake: UnstakeData,\n    }\n\n    #[overrider(PSP22VaultInternal)]\n    fn _deposit(\n        &mut self,\n        caller: &AccountId,\n        receiver: &AccountId,\n        assets: &Balance,\n        shares: &Balance,\n    ) -> Result<(), PSP22Error> {\n        self.counter.increase_counter(*shares);\n        self.govern.set_last_stake_timestamp(receiver);\n        self._deposit_default_impl(caller, receiver, assets, shares)?;\n\n        Ok(())\n    }\n\n    #[overrider(PSP22VaultInternal)]\n    fn _withdraw(\n        &mut self,\n        caller: &AccountId,\n        receiver: &AccountId,\n        owner: &AccountId,\n        assets: &Balance,\n        shares: &Balance,\n    ) -> Result<(), PSP22Error> {\n        if *caller != *owner && *caller != self.env().account_id() {\n            self._decrease_allowance_from_to(owner, caller, shares)?;\n        }\n\n        self._burn_from(owner, shares)?;\n\n        if self._balance_of(owner) == 0 {\n            self.govern.remove_last_stake_timestamp(owner);\n        }\n\n        self.vault\n            .asset()\n            .call_mut()\n            .approve(self.unstake.general_vester().to_account_id(), *assets)\n            .call_v1()\n            .invoke()?;\n\n        match self\n            .unstake\n            .general_vester()\n            .call_mut()\n            .create_vest(\n                *receiver,\n                Some(self.vault.asset().to_account_id()),\n                *assets,\n                VestingSchedule::External(ExternalTimeConstraint {\n                    account: self.env().account_id(),\n                    fallback_values: (self.unstake.unstake_period(), 0),\n                }),\n                Vec::<u8>::new(),\n            )\n            .call_v1()\n            .invoke()\n        {\n            Ok(_) => {}\n            Err(_) => {\n                return Err(PSP22Error::Custom(\n                    \"Failed during create vest call\".to_string(),\n                ))\n            }\n        }\n\n        ink::env::emit_event::<DefaultEnvironment, Withdraw>(Withdraw {\n            sender: *caller,\n            receiver: *receiver,\n            owner: *owner,\n            assets: *assets,\n            shares: *shares,\n        });\n        Ok(())\n    }\n\n    #[overrider(PSP22)]\n    fn transfer(&mut self, to: AccountId, value: Balance, data: Vec<u8>) -> Result<(), PSP22Error> {\n        Err(PSP22Error::Custom(\"Untransferrable\".to_string()))\n    }\n\n    #[overrider(PSP22)]\n    fn transfer_from(\n        &mut self,\n        from: AccountId,\n        to: AccountId,\n        value: Balance,\n        data: Vec<u8>,\n    ) -> Result<(), PSP22Error> {\n        Err(PSP22Error::Custom(\"Untransferrable\".to_string()))\n    }\n\n    impl AbaxGovernor {\n        #[allow(clippy::too_many_arguments)]\n        #[ink(constructor)]\n        pub fn new(\n            asset: AccountId,\n            vester: AccountId,\n            foundation: AccountId,\n            parameters_admin: Option<AccountId>,\n            unstake_period: Timestamp,\n            name: String,\n            symbol: String,\n            rules: VotingRules,\n        ) -> Result<Self, GovernError> {\n            _ensure_voting_rules_and_unstake_period_are_valid(&rules, unstake_period)?;\n\n            let mut instance = Self {\n                access_control: AccessControlData::new(Some(Self::env().account_id())),\n                psp22: PSP22Data::default(),\n                vault: PSP22VaultData::new(asset, None),\n                metadata: PSP22MetadataData::new(Some(name), Some(symbol)),\n                govern: GovernData::new(&rules),\n                counter: VaultCounterData::default(),\n                lock: LockedSharesData::default(),\n                unstake: UnstakeData::new(vester, unstake_period),\n            };\n\n            if let Some(admin) = parameters_admin {\n                instance._grant_role(PARAMETERS_ADMIN, Some(admin))?;\n            }\n\n            instance._grant_role(EXECUTOR, Some(foundation))?;\n            Ok(instance)\n        }\n    }\n\n    impl AbaxGovern for AbaxGovernor {\n        #[ink(message)]\n        fn propose(&mut self, proposal: Proposal) -> Result<ProposalId, GovernError> {\n            self._propose(&self.env().caller(), &proposal)\n        }\n\n        #[ink(message)]\n        fn finalize(&mut self, proposal_id: ProposalId) -> Result<(), GovernError> {\n            self._finalize(&proposal_id)\n        }\n\n        #[ink(message)]\n        fn execute(&mut self, proposal: Proposal) -> Result<(), GovernError> {\n            self._ensure_has_role(EXECUTOR, Some(self.env().caller()))?;\n            self._execute(&proposal)\n        }\n\n        #[ink(message)]\n        fn vote(\n            &mut self,\n            proposal_id: ProposalId,\n            vote: Vote,\n            _reason: Vec<u8>,\n        ) -> Result<(), GovernError> {\n            self._cast_vote(&self.env().caller(), proposal_id, vote, _reason)\n        }\n\n        #[ink(message)]\n        fn force_unstake(\n            &mut self,\n            account: AccountId,\n            proposal_id: ProposalId,\n        ) -> Result<(), GovernError> {\n            self._force_unstake(&account, &proposal_id)?;\n            Ok(())\n        }\n    }\n\n    impl AbaxGovernManage for AbaxGovernor {\n        #[ink(message)]\n        fn change_voting_rules(&mut self, rules: VotingRules) -> Result<(), GovernError> {\n            _ensure_voting_rules_and_unstake_period_are_valid(\n                &rules,\n                self.unstake.unstake_period(),\n            )?;\n            self._ensure_has_role(PARAMETERS_ADMIN, Some(self.env().caller()))?;\n            self.govern.change_rule(&rules);\n            ink::env::emit_event::<DefaultEnvironment, VotingRulesChanged>(VotingRulesChanged {\n                rules,\n            });\n            Ok(())\n        }\n\n        #[ink(message)]\n        fn change_unstake_period(&mut self, period: Timestamp) -> Result<(), GovernError> {\n            _ensure_voting_rules_and_unstake_period_are_valid(&self.rules(), period)?;\n            self._ensure_has_role(PARAMETERS_ADMIN, Some(self.env().caller()))?;\n            self.unstake.set_unstake_period(period);\n            ink::env::emit_event::<DefaultEnvironment, UnstakePeriodChanged>(\n                UnstakePeriodChanged {\n                    unstake_period: period,\n                },\n            );\n            Ok(())\n        }\n    }\n\n    impl AbaxGovernView for AbaxGovernor {\n        #[ink(message)]\n        fn vester(&self) -> AccountId {\n            self.unstake.general_vester().to_account_id()\n        }\n\n        #[ink(message)]\n        fn hash(&self, proposal: Proposal) -> ProposalHash {\n            hash_proposal(&proposal)\n        }\n\n        #[ink(message)]\n        fn hash_description(&self, description: String) -> Hash {\n            hash_description(&description)\n        }\n\n        #[ink(message)]\n        fn hash_by_id(&self, proposal_id: ProposalId) -> Option<ProposalHash> {\n            self.govern.proposal_id_to_hash(&proposal_id)\n        }\n\n        #[ink(message)]\n        fn rules(&self) -> VotingRules {\n            self.govern.rules()\n        }\n\n        #[ink(message)]\n        fn status(&self, proposal_id: ProposalId) -> Option<ProposalStatus> {\n            self.govern.state_of(&proposal_id).map(|state| state.status)\n        }\n\n        #[ink(message)]\n        fn minimum_to_finalize(&self, proposal_id: ProposalId) -> Option<Balance> {\n            let state = match self.govern.state_of(&proposal_id) {\n                Some(state) => state,\n                None => return None,\n            };\n\n            if state.status != ProposalStatus::Active {\n                return None;\n            }\n\n            Some(\n                minimum_to_finalize(\n                    &state,\n                    &self.rules(),\n                    ink::env::block_timestamp::<DefaultEnvironment>(),\n                    self.counter.counter(),\n                )\n                .unwrap(),\n            )\n        }\n\n        #[ink(message)]\n        fn state(&self, proposal_id: ProposalId) -> Option<ProposalState> {\n            self.govern.state_of(&proposal_id)\n        }\n\n        #[ink(message)]\n        fn vote_of_for(&self, account: AccountId, proposal_id: ProposalId) -> Option<UserVote> {\n            self.govern.vote_of_for(&account, &proposal_id)\n        }\n\n        #[ink(message)]\n        fn last_force_unstakes(&self, account: AccountId) -> Option<ProposalId> {\n            self.govern.last_force_unstake(&account)\n        }\n\n        #[ink(message)]\n        fn last_stake_timestamp(&self, account: AccountId) -> Option<Timestamp> {\n            self.govern.last_stake_timestamp(&account)\n        }\n\n        #[ink(message)]\n        fn active_proposals(&self) -> u32 {\n            self.govern.active_proposals()\n        }\n\n        #[ink(message)]\n        fn finalized_proposals(&self) -> u32 {\n            self.govern.finalized_proposals()\n        }\n\n        #[ink(message)]\n        fn executed_proposals(&self) -> u32 {\n            self.govern.executed_proposals()\n        }\n\n        #[ink(message)]\n        fn next_proposal_id(&self) -> ProposalId {\n            self.govern.next_proposal_id()\n        }\n        #[ink(message)]\n        fn description_url_by_proposal_id(&self, proposal_id: ProposalId) -> Option<String> {\n            self.govern.proposal_id_to_description_url(&proposal_id)\n        }\n        #[ink(message)]\n        fn description_hash_by_proposal_id(&self, proposal_id: ProposalId) -> Option<Hash> {\n            self.govern.proposal_id_to_description_hash(&proposal_id)\n        }\n    }\n\n    impl AbaxGovernInternal for AbaxGovernor {\n        fn _propose(\n            &mut self,\n            proposer: &AccountId,\n            proposal: &Proposal,\n        ) -> Result<ProposalId, GovernError> {\n            //check if the proposer has enough votes to create a proposal\n            let total_votes = self._total_supply();\n            let minimum_votes_to_propose = mul_div(\n                total_votes,\n                u128::from(self.govern.rules().minimum_stake_part_e3),\n                1000,\n                Rounding::Down,\n            )?;\n\n            let proposer_votes = self._balance_of(proposer);\n            if proposer_votes < minimum_votes_to_propose {\n                return Err(GovernError::InsuficientVotes);\n            }\n            let proposal_hash = hash_proposal(proposal);\n\n            // make a proposer deposit\n            let proposer_deposit = mul_div(\n                minimum_votes_to_propose,\n                self.govern.rules().proposer_deposit_part_e3 as u128,\n                1000,\n                Rounding::Down,\n            )?;\n            // create proposal\n            let proposal_id = self.govern.register_new_proposal(\n                proposer,\n                &proposal_hash,\n                proposal.earliest_execution,\n                &proposal.description_url,\n                &proposal.description_hash,\n                total_votes,\n                self.counter.counter(),\n            )?;\n\n            self.lock.lock(&proposal_id, proposer_deposit)?;\n\n            self._transfer(proposer, &self.env().account_id(), &proposer_deposit)?;\n\n            ink::env::emit_event::<DefaultEnvironment, ProposalCreated>(ProposalCreated {\n                proposal_id,\n                proposal_hash,\n                proposal: proposal.clone(),\n            });\n            Ok(proposal_id)\n        }\n\n        fn _cast_vote(\n            &mut self,\n            voter: &AccountId,\n            proposal_id: ProposalId,\n            vote: Vote,\n            #[allow(unused_variables)] reason: Vec<u8>,\n        ) -> Result<(), GovernError> {\n            let voter_votes = {\n                let balance = self._balance_of(voter);\n                let locked = self.lock.locked(&proposal_id);\n                let proposer = self\n                    .govern\n                    .state_of(&proposal_id)\n                    .ok_or(GovernError::ProposalDoesntExist)?\n                    .proposer;\n                if self.env().caller() == proposer {\n                    balance.checked_add(locked).ok_or(MathError::Overflow)?\n                } else {\n                    balance\n                }\n            };\n\n            self.govern\n                .update_vote_of_for(voter, &proposal_id, &vote, &voter_votes)?;\n\n            ink::env::emit_event::<DefaultEnvironment, VoteCasted>(VoteCasted {\n                account: *voter,\n                proposal_id,\n                vote,\n            });\n\n            Ok(())\n        }\n\n        fn _finalize(&mut self, proposal_id: &ProposalId) -> Result<(), GovernError> {\n            let status = self.govern.finalize(proposal_id, self.counter.counter())?;\n\n            // return the proposer deposit if proposal was not 'DefeatedWithSlash'\n            if status != ProposalStatus::DefeatedWithSlash {\n                let locked = self.lock.locked(proposal_id);\n                self.lock.unlock(proposal_id, locked)?;\n                self._transfer(\n                    &self.env().account_id(),\n                    &self.govern.state_of(proposal_id).unwrap().proposer,\n                    &locked,\n                )?;\n            }\n\n            ink::env::emit_event::<DefaultEnvironment, ProposalFinalized>(ProposalFinalized {\n                proposal_id: *proposal_id,\n                status,\n            });\n            Ok(())\n        }\n\n        fn _execute(&mut self, proposal: &Proposal) -> Result<(), GovernError> {\n            let proposal_hash = hash_proposal(proposal);\n\n            let proposal_id = &self\n                .govern\n                .proposal_hash_to_id(&proposal_hash)\n                .ok_or(GovernError::ProposalDoesntExist)?;\n\n            self.govern.mark_as_executed(proposal_id)?;\n\n            for tx in &proposal.transactions {\n                self.flush();\n\n                // let call = tx.clone().build_call();\n                let call = ink::env::call::build_call::<DefaultEnvironment>()\n                    .call_v1(tx.callee)\n                    .transferred_value(tx.transferred_value)\n                    .call_flags(ink::env::CallFlags::ALLOW_REENTRY)\n                    .exec_input(\n                        ink::env::call::ExecutionInput::new(tx.selector.into())\n                            .push_arg(OpaqueTypes(tx.input.clone())),\n                    )\n                    .returns::<OpaqueTypes>()\n                    .try_invoke();\n                match call {\n                    Ok(contract_res) => match contract_res {\n                        Ok(_) => Ok(()),\n                        Err(e) => Err(GovernError::UnderlyingTransactionReverted(\n                            ink::prelude::format!(\"{:?}\", e),\n                        )),\n                    },\n                    Err(e) => match e {\n                        ink::env::Error::Decode(err) => {\n                            Err(GovernError::UnderlyingTransactionReverted(\n                                ink::prelude::format!(\"Decode Error: {:?}\", err),\n                            ))\n                        }\n                        _ => Err(GovernError::UnderlyingTransactionReverted(\n                            ink::prelude::format!(\"{:?}\", e),\n                        )),\n                    },\n                }?;\n                self.load();\n            }\n\n            ink::env::emit_event::<DefaultEnvironment, ProposalExecuted>(ProposalExecuted {\n                proposal_id: *proposal_id,\n            });\n\n            Ok(())\n        }\n\n        fn _force_unstake(\n            &mut self,\n            account: &AccountId,\n            proposal_id: &ProposalId,\n        ) -> Result<(), GovernError> {\n            self.govern.force_unstake(account, proposal_id)?;\n            let balance = self._balance_of(account);\n            let assets = self._preview_redeem(&balance)?;\n            self._withdraw(\n                &self.env().account_id(),\n                account,\n                account,\n                &assets,\n                &balance,\n            )?;\n\n            Ok(())\n        }\n    }\n\n    impl ProvideVestScheduleInfo for AbaxGovernor {\n        #[ink(message)]\n        fn get_waiting_and_vesting_durations(&self) -> (Timestamp, Timestamp) {\n            (self.unstake.unstake_period(), 0)\n        }\n    }\n\n    fn _ensure_voting_rules_and_unstake_period_are_valid(\n        rules: &VotingRules,\n        unstake_period: Timestamp,\n    ) -> Result<(), GovernError> {\n        if rules\n            .initial_period\n            .checked_add(rules.flat_period)\n            .ok_or(MathError::Overflow)?\n            .checked_add(rules.final_period)\n            .ok_or(MathError::Overflow)?\n            > unstake_period\n        {\n            return Err(GovernError::UnstakeShorterThanVotingPeriod);\n        }\n        Ok(())\n    }\n}\n",
        "modules/govern/helpers/finalization.rs":"use pendzl::{\n    math::errors::MathError,\n    traits::{Balance, Timestamp},\n};\n\nuse crate::modules::govern::{\n    helpers::mul_div::mul_div_r_down,\n    traits::{ProposalState, VotingRules},\n};\n\npub fn minimum_to_finalize(\n    state: &ProposalState,\n    rules: &VotingRules,\n    now: Timestamp,\n    current_counter: u128,\n) -> Result<Balance, MathError> {\n    let initial_period_end = state\n        .start\n        .checked_add(rules.initial_period)\n        .ok_or(MathError::Overflow)?;\n    let flat_period_end = initial_period_end\n        .checked_add(rules.flat_period)\n        .ok_or(MathError::Overflow)?;\n    let final_period_end = flat_period_end\n        .checked_add(rules.final_period)\n        .ok_or(MathError::Overflow)?;\n\n    let counter_diff = current_counter.overflowing_sub(state.counter_at_start).0;\n    let total_votes = state\n        .votes_at_start\n        .checked_add(counter_diff)\n        .ok_or(MathError::Overflow)?;\n\n    //print all of args and above\n\n    let half_total_votes = total_votes.checked_div(2).ok_or(MathError::DivByZero)?;\n\n    Ok(if now <= initial_period_end {\n        let time_in_initial_period = initial_period_end\n            .checked_sub(now)\n            .ok_or(MathError::Underflow)? as u128;\n        let over_half = mul_div_r_down(\n            half_total_votes,\n            time_in_initial_period,\n            rules.initial_period as u128,\n        )?;\n        half_total_votes\n            .checked_add(over_half)\n            .ok_or(MathError::Overflow)?\n    } else if now <= flat_period_end {\n        half_total_votes\n    } else if now <= final_period_end {\n        let time_in_final_period = final_period_end\n            .checked_sub(now)\n            .ok_or(MathError::Underflow)? as u128;\n        mul_div_r_down(\n            half_total_votes,\n            time_in_final_period,\n            rules.final_period as u128,\n        )?\n    } else {\n        0\n    })\n}\n",
        "modules/govern/helpers/hashes.rs":"pub use ink::{\n    env::hash::{HashOutput, Sha2x256},\n    prelude::{string::String, vec::Vec},\n    primitives::Hash,\n};\n\npub use crate::modules::govern::traits::Proposal;\n\npub fn hash_description(description: &String) -> Hash {\n    let mut output = <Sha2x256 as HashOutput>::Type::default();\n    ink::env::hash_bytes::<Sha2x256>(description.as_bytes(), &mut output);\n    output.into()\n}\npub fn hash_proposal(proposal: &Proposal) -> Hash {\n    let mut hash_data: Vec<u8> = Vec::new();\n\n    hash_data.append(&mut scale::Encode::encode(&proposal));\n\n    let mut output = <Sha2x256 as HashOutput>::Type::default();\n    ink::env::hash_bytes::<Sha2x256>(&hash_data, &mut output);\n    output.into()\n}\n",
        "modules/govern/helpers/mod.rs":"pub mod finalization;\npub mod hashes;\npub mod mul_div;\n",
        "modules/govern/helpers/mul_div.rs":"use ethnum::U256;\nuse pendzl::math::errors::MathError;\n\npub fn mul_div_r_down(x: u128, y: u128, denominator: u128) -> Result<u128, MathError> {\n    if denominator == 0 {\n        return Err(MathError::DivByZero);\n    }\n\n    if x == 0 || y == 0 {\n        return Ok(0);\n    }\n\n    let x_u256 = U256::try_from(x).unwrap();\n    let y_u256 = U256::try_from(y).unwrap();\n    let denominator_u256 = U256::try_from(denominator).unwrap();\n\n    // this can not overflow\n    let mul_u256 = x_u256.checked_mul(y_u256).unwrap();\n    // denom is not 0\n    let res_u256: U256 = mul_u256.checked_div(denominator_u256).unwrap();\n    let res = match u128::try_from(res_u256) {\n        Ok(v) => Ok(v),\n        _ => Err(MathError::Overflow)?,\n    }?;\n\n    Ok(res)\n}\n",
        "modules/govern/mod.rs":"pub mod helpers;\npub mod storage;\npub mod traits;\n",
        "modules/govern/storage/govern_storage_item.rs":"use ink::{\n    env::DefaultEnvironment, prelude::string::ToString, primitives::AccountId, storage::Mapping,\n};\nuse pendzl::{\n    math::errors::MathError,\n    traits::{Balance, Hash, String, Timestamp},\n};\n\nuse crate::modules::govern::{\n    helpers::finalization::minimum_to_finalize,\n    traits::{GovernError, ProposalId, ProposalState, ProposalStatus, UserVote, Vote, VotingRules},\n};\n\n#[derive(Debug)]\n#[pendzl::storage_item]\npub struct GovernData {\n    #[lazy]\n    rules: VotingRules,\n    #[lazy]\n    active_proposals: u32,\n    #[lazy]\n    finalized_proposals: u32,\n    #[lazy]\n    executed_proposals: u32,\n    #[lazy]\n    next_proposal_id: ProposalId,\n    proposal_id_to_hash: Mapping<ProposalId, Hash>,\n    proposal_id_to_description_url: Mapping<ProposalId, String>,\n    proposal_id_to_description_hash: Mapping<ProposalId, Hash>,\n    proposal_hash_to_id: Mapping<Hash, ProposalId>,\n    state: Mapping<ProposalId, ProposalState>,\n    votes: Mapping<(AccountId, ProposalId), UserVote>,\n    /// Last time when the user staked and had no stake before, when user has no stake it should be None.\n    last_stake_timestamp: Mapping<AccountId, Timestamp>,\n    /// Last proposal that account didnt vote and was in consequence force unstaked\n    last_force_unstake: Mapping<AccountId, ProposalId>,\n}\n\nimpl GovernData {\n    pub fn new(rules: &VotingRules) -> Self {\n        let mut instance = Self {\n            rules: Default::default(),\n            active_proposals: Default::default(),\n            finalized_proposals: Default::default(),\n            executed_proposals: Default::default(),\n            next_proposal_id: Default::default(),\n            proposal_id_to_hash: Default::default(),\n            proposal_id_to_description_url: Default::default(),\n            proposal_id_to_description_hash: Default::default(),\n            proposal_hash_to_id: Default::default(),\n            state: Default::default(),\n            votes: Default::default(),\n            last_stake_timestamp: Default::default(),\n            last_force_unstake: Default::default(),\n        };\n        instance.rules.set(rules);\n        instance\n    }\n\n    pub fn set_last_stake_timestamp(&mut self, account: &AccountId) {\n        let timestamp = ink::env::block_timestamp::<DefaultEnvironment>();\n        if self.last_stake_timestamp(account).is_some() {\n            return;\n        }\n        self.last_stake_timestamp.insert(account, &timestamp);\n    }\n    pub fn remove_last_stake_timestamp(&mut self, account: &AccountId) {\n        self.last_stake_timestamp.remove(account);\n    }\n    pub fn last_stake_timestamp(&self, account: &AccountId) -> Option<Timestamp> {\n        self.last_stake_timestamp.get(account)\n    }\n    pub fn last_force_unstake(&self, account: &AccountId) -> Option<ProposalId> {\n        self.last_force_unstake.get(account)\n    }\n\n    pub fn rules(&self) -> VotingRules {\n        self.rules.get().unwrap_or_default()\n    }\n\n    pub fn change_rule(&mut self, rules: &VotingRules) {\n        self.rules.set(rules);\n    }\n\n    pub fn active_proposals(&self) -> u32 {\n        self.active_proposals.get().unwrap_or_default()\n    }\n\n    pub fn finalized_proposals(&self) -> u32 {\n        self.finalized_proposals.get().unwrap_or_default()\n    }\n\n    pub fn executed_proposals(&self) -> u32 {\n        self.executed_proposals.get().unwrap_or_default()\n    }\n\n    pub fn next_proposal_id(&self) -> ProposalId {\n        self.next_proposal_id.get().unwrap_or_default()\n    }\n\n    pub fn proposal_id_to_hash(&self, proposal_id: &ProposalId) -> Option<Hash> {\n        self.proposal_id_to_hash.get(proposal_id)\n    }\n\n    pub fn proposal_hash_to_id(&self, proposal_hash: &Hash) -> Option<ProposalId> {\n        self.proposal_hash_to_id.get(proposal_hash)\n    }\n    pub fn proposal_id_to_description_url(&self, proposal_id: &ProposalId) -> Option<String> {\n        self.proposal_id_to_description_url.get(proposal_id)\n    }\n    pub fn proposal_id_to_description_hash(&self, proposal_id: &ProposalId) -> Option<Hash> {\n        self.proposal_id_to_description_hash.get(proposal_id)\n    }\n\n    #[allow(clippy::too_many_arguments)]\n    pub fn register_new_proposal(\n        &mut self,\n        proposer: &AccountId,\n        proposal_hash: &Hash,\n        earliest_execution: Option<Timestamp>,\n        description_url: &String,\n        description_hash: &Hash,\n        votes_at_start: Balance,\n        counter_at_start: u128,\n    ) -> Result<ProposalId, GovernError> {\n        if self.proposal_hash_to_id(proposal_hash).is_some() {\n            return Err(GovernError::ProposalAlreadyExists);\n        }\n\n        let proposal_id = self.next_proposal_id();\n        self.next_proposal_id\n            .set(&(proposal_id.checked_add(1).ok_or(MathError::Overflow)?));\n\n        self.proposal_id_to_hash.insert(proposal_id, proposal_hash);\n        self.proposal_hash_to_id.insert(proposal_hash, &proposal_id);\n        self.proposal_id_to_description_url\n            .insert(proposal_id, &description_url.to_string());\n        self.proposal_id_to_description_hash\n            .insert(proposal_id, description_hash);\n\n        self.state.insert(\n            proposal_id,\n            &ProposalState {\n                status: ProposalStatus::Active,\n                force_unstake_possible: false,\n                proposer: *proposer,\n                start: ink::env::block_timestamp::<DefaultEnvironment>(),\n                counter_at_start,\n                votes_at_start,\n                finalized: None,\n                votes_for: 0,\n                votes_against: 0,\n                votes_against_with_slash: 0,\n                earliest_execution,\n            },\n        );\n\n        self.active_proposals.set(\n            &(self\n                .active_proposals()\n                .checked_add(1)\n                .ok_or(MathError::Overflow)?),\n        );\n\n        Ok(proposal_id)\n    }\n\n    pub fn finalize(\n        &mut self,\n        proposal_id: &ProposalId,\n        current_counter: u128,\n    ) -> Result<ProposalStatus, GovernError> {\n        let mut state = self\n            .state_of(proposal_id)\n            .ok_or(GovernError::ProposalDoesntExist)?;\n\n        if state.status != ProposalStatus::Active {\n            return Err(GovernError::WrongStatus);\n        }\n        let now = ink::env::block_timestamp::<DefaultEnvironment>();\n\n        let minimum_to_finalize = minimum_to_finalize(&state, &self.rules(), now, current_counter)?;\n\n        if state\n            .votes_against\n            .checked_add(state.votes_against_with_slash)\n            .ok_or(MathError::Overflow)?\n            < minimum_to_finalize\n            && state.votes_for < minimum_to_finalize\n        {\n            return Err(GovernError::FinalizeCondition);\n        }\n\n        if state\n            .votes_against\n            .checked_add(state.votes_against_with_slash)\n            .ok_or(MathError::Overflow)?\n            >= state.votes_for\n        {\n            if state.votes_against_with_slash\n                > state\n                    .votes_against\n                    .checked_add(state.votes_for)\n                    .ok_or(MathError::Overflow)?\n            {\n                state.status = ProposalStatus::DefeatedWithSlash;\n            } else {\n                state.status = ProposalStatus::Defeated;\n            }\n        } else if state.votes_for\n            > state\n                .votes_against\n                .checked_add(state.votes_against_with_slash)\n                .ok_or(MathError::Overflow)?\n        {\n            state.status = ProposalStatus::Succeeded;\n        } else {\n            state.status = ProposalStatus::Defeated;\n        }\n\n        let initital_plus_flat_duration = self\n            .rules()\n            .initial_period\n            .checked_add(self.rules().flat_period)\n            .ok_or(MathError::Overflow)?;\n\n        let is_post_flat_period = now\n            >= state\n                .start\n                .checked_add(initital_plus_flat_duration)\n                .ok_or(MathError::Overflow)?;\n        if is_post_flat_period {\n            state.force_unstake_possible = true;\n        }\n\n        state.finalized = Some(now);\n\n        self.state.insert(proposal_id, &state);\n        self.active_proposals.set(\n            &(self\n                .active_proposals()\n                .checked_sub(1)\n                .ok_or(MathError::Overflow)?),\n        );\n        self.finalized_proposals.set(\n            &(self\n                .finalized_proposals()\n                .checked_add(1)\n                .ok_or(MathError::Overflow)?),\n        );\n\n        Ok(state.status)\n    }\n\n    pub fn mark_as_executed(&mut self, proposal_id: &ProposalId) -> Result<(), GovernError> {\n        let mut state = self\n            .state_of(proposal_id)\n            .ok_or(GovernError::ProposalDoesntExist)?;\n        if state.earliest_execution.unwrap_or_default()\n            > ink::env::block_timestamp::<DefaultEnvironment>()\n        {\n            return Err(GovernError::TooEarlyToExecuteProposal);\n        }\n        if state.status != ProposalStatus::Succeeded {\n            return Err(GovernError::WrongStatus);\n        }\n        state.status = ProposalStatus::Executed;\n        self.state.insert(proposal_id, &state);\n        Ok(())\n    }\n\n    pub fn state_of(&self, proposal_id: &ProposalId) -> Option<ProposalState> {\n        self.state.get(proposal_id)\n    }\n\n    pub fn status_of(&self, proposal_id: &ProposalId) -> Option<ProposalStatus> {\n        self.state_of(proposal_id).map(|state| state.status)\n    }\n\n    pub fn vote_of_for(&self, account: &AccountId, proposal_id: &ProposalId) -> Option<UserVote> {\n        self.votes.get((*account, *proposal_id))\n    }\n\n    pub fn update_vote_of_for(\n        &mut self,\n        account: &AccountId,\n        proposal_id: &ProposalId,\n        vote: &Vote,\n        amount: &Balance,\n    ) -> Result<(), GovernError> {\n        if *amount == 0 {\n            return Err(GovernError::InsuficientVotes);\n        }\n        let mut state = self\n            .state_of(proposal_id)\n            .ok_or(GovernError::ProposalDoesntExist)?;\n        if state.status != ProposalStatus::Active {\n            return Err(GovernError::WrongStatus);\n        }\n\n        let existing_user_vote = self.vote_of_for(account, proposal_id);\n        match existing_user_vote {\n            None => match vote {\n                Vote::Agreed => {\n                    state.votes_for = state\n                        .votes_for\n                        .checked_add(*amount)\n                        .ok_or(MathError::Overflow)?\n                }\n                Vote::Disagreed => {\n                    state.votes_against = state\n                        .votes_against\n                        .checked_add(*amount)\n                        .ok_or(MathError::Overflow)?\n                }\n                Vote::DisagreedWithProposerSlashing => {\n                    state.votes_against_with_slash = state\n                        .votes_against_with_slash\n                        .checked_add(*amount)\n                        .ok_or(MathError::Overflow)?\n                }\n            },\n            Some(old_vote) => match old_vote.vote {\n                Vote::Agreed => match vote {\n                    Vote::Agreed => {\n                        state.votes_for = state\n                            .votes_for\n                            .checked_sub(old_vote.amount)\n                            .ok_or(MathError::Underflow)?;\n                        state.votes_for = state\n                            .votes_for\n                            .checked_add(*amount)\n                            .ok_or(MathError::Overflow)?;\n                    }\n                    Vote::Disagreed => {\n                        state.votes_for = state\n                            .votes_for\n                            .checked_sub(old_vote.amount)\n                            .ok_or(MathError::Underflow)?;\n                        state.votes_against = state\n                            .votes_against\n                            .checked_add(*amount)\n                            .ok_or(MathError::Overflow)?;\n                    }\n                    Vote::DisagreedWithProposerSlashing => {\n                        state.votes_for = state\n                            .votes_for\n                            .checked_sub(old_vote.amount)\n                            .ok_or(MathError::Underflow)?;\n                        state.votes_against_with_slash = state\n                            .votes_against_with_slash\n                            .checked_add(*amount)\n                            .ok_or(MathError::Overflow)?;\n                    }\n                },\n                Vote::Disagreed => match vote {\n                    Vote::Agreed => {\n                        state.votes_against = state\n                            .votes_against\n                            .checked_sub(old_vote.amount)\n                            .ok_or(MathError::Underflow)?;\n                        state.votes_for = state\n                            .votes_for\n                            .checked_add(*amount)\n                            .ok_or(MathError::Overflow)?;\n                    }\n                    Vote::Disagreed => {\n                        state.votes_against = state\n                            .votes_against\n                            .checked_sub(old_vote.amount)\n                            .ok_or(MathError::Underflow)?;\n                        state.votes_against = state\n                            .votes_against\n                            .checked_add(*amount)\n                            .ok_or(MathError::Overflow)?;\n                    }\n                    Vote::DisagreedWithProposerSlashing => {\n                        state.votes_against = state\n                            .votes_against\n                            .checked_sub(old_vote.amount)\n                            .ok_or(MathError::Underflow)?;\n                        state.votes_against_with_slash = state\n                            .votes_against_with_slash\n                            .checked_add(*amount)\n                            .ok_or(MathError::Overflow)?;\n                    }\n                },\n                Vote::DisagreedWithProposerSlashing => match vote {\n                    Vote::Agreed => {\n                        state.votes_against_with_slash = state\n                            .votes_against_with_slash\n                            .checked_sub(old_vote.amount)\n                            .ok_or(MathError::Underflow)?;\n                        state.votes_for = state\n                            .votes_for\n                            .checked_add(*amount)\n                            .ok_or(MathError::Overflow)?;\n                    }\n                    Vote::Disagreed => {\n                        state.votes_against_with_slash = state\n                            .votes_against_with_slash\n                            .checked_sub(old_vote.amount)\n                            .ok_or(MathError::Underflow)?;\n                        state.votes_against = state\n                            .votes_against\n                            .checked_add(*amount)\n                            .ok_or(MathError::Overflow)?;\n                    }\n                    Vote::DisagreedWithProposerSlashing => {\n                        state.votes_against_with_slash = state\n                            .votes_against_with_slash\n                            .checked_sub(old_vote.amount)\n                            .ok_or(MathError::Underflow)?;\n                        state.votes_against_with_slash = state\n                            .votes_against_with_slash\n                            .checked_add(*amount)\n                            .ok_or(MathError::Overflow)?;\n                    }\n                },\n            },\n        }\n\n        let new_vote = UserVote {\n            vote: *vote,\n            amount: *amount,\n        };\n\n        self.votes.insert((*account, *proposal_id), &new_vote);\n\n        self.state.insert(proposal_id, &state);\n        Ok(())\n    }\n\n    pub fn force_unstake(\n        &mut self,\n        account: &AccountId,\n        proposal_id: &ProposalId,\n    ) -> Result<(), GovernError> {\n        let state = self\n            .state_of(proposal_id)\n            .ok_or(GovernError::ProposalDoesntExist)?;\n\n        if !state.force_unstake_possible {\n            return Err(GovernError::CantForceUnstake);\n        }\n\n        if state.finalized.unwrap_or_default()\n            <= self.last_stake_timestamp(account).unwrap_or_default()\n        {\n            return Err(GovernError::CantForceUnstake);\n        }\n        if self.vote_of_for(account, proposal_id).is_some() {\n            return Err(GovernError::CantForceUnstake);\n        }\n\n        if let Some(last_proposal_id) = self.last_force_unstake.get(account) {\n            if last_proposal_id >= *proposal_id {\n                return Err(GovernError::CantForceUnstake);\n            }\n        }\n        self.last_force_unstake.insert(account, proposal_id);\n        Ok(())\n    }\n}\n",
        "modules/govern/storage/locked_shares_storage_item.rs":"use ink::storage::Mapping;\nuse pendzl::{math::errors::MathError, traits::Balance};\n\nuse crate::modules::govern::traits::ProposalId;\n\n#[derive(Debug, Default)]\n#[pendzl::storage_item]\npub struct LockedSharesData {\n    locked: Mapping<ProposalId, Balance>,\n}\n\nimpl LockedSharesData {\n    pub fn locked(&self, proposal_id: &ProposalId) -> Balance {\n        self.locked.get(proposal_id).unwrap_or_default()\n    }\n\n    pub fn lock(&mut self, proposal_id: &ProposalId, amount: Balance) -> Result<(), MathError> {\n        let mut locked = self.locked(proposal_id);\n        locked = locked.checked_add(amount).ok_or(MathError::Overflow)?;\n        self.locked.insert(proposal_id, &locked);\n        Ok(())\n    }\n\n    pub fn unlock(&mut self, proposal_id: &ProposalId, amount: Balance) -> Result<(), MathError> {\n        let mut locked = self.locked(proposal_id);\n        locked = locked.checked_sub(amount).ok_or(MathError::Underflow)?;\n        if locked > 0 {\n            self.locked.insert(proposal_id, &locked);\n        } else {\n            self.locked.remove(proposal_id);\n        }\n        Ok(())\n    }\n}\n",
        "modules/govern/storage/mod.rs":"pub mod govern_storage_item;\npub mod locked_shares_storage_item;\npub mod unstake_storage_item;\npub mod vault_counter_storage_item;\n",
        "modules/govern/storage/unstake_storage_item.rs":"use ink::{env::DefaultEnvironment, primitives::AccountId};\npub use pendzl::contracts::general_vest::GeneralVestRef;\nuse pendzl::traits::Timestamp;\n\nuse crate::modules::govern::traits::UnstakePeriodChanged;\n\n#[derive(Debug, Default)]\n#[pendzl::storage_item]\npub struct UnstakeData {\n    #[lazy]\n    general_vester: GeneralVestRef,\n    #[lazy]\n    unstake_period: Timestamp,\n}\n\nimpl UnstakeData {\n    pub fn new(general_vester_address: AccountId, unstake_period: Timestamp) -> Self {\n        let mut instance = Self::default();\n        instance.set_general_vester(&general_vester_address);\n        instance.set_unstake_period(unstake_period);\n        ink::env::emit_event::<DefaultEnvironment, UnstakePeriodChanged>(UnstakePeriodChanged {\n            unstake_period,\n        });\n        instance\n    }\n}\n\nimpl UnstakeData {\n    pub fn general_vester(&self) -> GeneralVestRef {\n        self.general_vester.get().unwrap()\n    }\n\n    pub fn unstake_period(&self) -> Timestamp {\n        self.unstake_period.get().unwrap_or_default()\n    }\n\n    pub fn set_general_vester(&mut self, vester: &AccountId) {\n        let vester: GeneralVestRef = (*vester).into();\n        self.general_vester.set(&vester);\n    }\n\n    pub fn set_unstake_period(&mut self, period: Timestamp) {\n        self.unstake_period.set(&period);\n    }\n}\n",
        "modules/govern/storage/vault_counter_storage_item.rs":"#[derive(Debug, Default)]\n#[pendzl::storage_item]\npub struct VaultCounterData {\n    #[lazy]\n    counter: u128,\n}\n\nimpl VaultCounterData {\n    pub fn counter(&self) -> u128 {\n        self.counter.get().unwrap_or_default()\n    }\n\n    pub fn increase_counter(&mut self, amount: u128) {\n        let mut counter = self.counter();\n        counter = counter.overflowing_add(amount).0;\n        self.counter.set(&counter);\n    }\n}\n",
        "modules/govern/traits/errors.rs":"use pendzl::traits::String;\npub use pendzl::{\n    contracts::{access_control::AccessControlError, psp22::PSP22Error},\n    math::errors::MathError,\n};\n\n#[derive(scale::Encode, scale::Decode, Debug)]\n#[cfg_attr(feature = \"std\", derive(scale_info::TypeInfo))]\npub enum GovernError {\n    MathError(MathError),\n    PSP22Error(PSP22Error),\n    InsuficientVotes,\n    ProposalAlreadyExists,\n    ProposalDoesntExist,\n    WrongStatus,\n    TooEarlyToExecuteProposal,\n    FinalizeCondition,\n    UnderlyingTransactionReverted(String),\n    CantForceUnstake,\n    AccessControlError(AccessControlError),\n    UnstakeShorterThanVotingPeriod,\n}\n\nimpl From<MathError> for GovernError {\n    fn from(error: MathError) -> Self {\n        GovernError::MathError(error)\n    }\n}\n\nimpl From<PSP22Error> for GovernError {\n    fn from(error: PSP22Error) -> Self {\n        GovernError::PSP22Error(error)\n    }\n}\n\nimpl From<AccessControlError> for GovernError {\n    fn from(error: AccessControlError) -> Self {\n        GovernError::AccessControlError(error)\n    }\n}\n",
        "modules/govern/traits/events.rs":"use pendzl::traits::{AccountId, Timestamp};\n\nuse super::{Proposal, ProposalHash, ProposalId, ProposalStatus, Vote, VotingRules};\n\n#[ink::event]\npub struct ProposalCreated {\n    #[ink(topic)]\n    pub proposal_id: ProposalId,\n    #[ink(topic)]\n    pub proposal_hash: ProposalHash,\n    #[ink(topic)]\n    pub proposal: Proposal,\n}\n\n#[ink::event]\npub struct ProposalFinalized {\n    #[ink(topic)]\n    pub proposal_id: ProposalId,\n    #[ink(topic)]\n    pub status: ProposalStatus,\n}\n\n#[ink::event]\npub struct ProposalExecuted {\n    #[ink(topic)]\n    pub proposal_id: ProposalId,\n}\n\n#[ink::event]\npub struct VoteCasted {\n    #[ink(topic)]\n    pub account: AccountId,\n    #[ink(topic)]\n    pub proposal_id: ProposalId,\n    pub vote: Vote,\n}\n\n#[ink::event]\npub struct VotingRulesChanged {\n    pub rules: VotingRules,\n}\n\n#[ink::event]\npub struct UnstakePeriodChanged {\n    pub unstake_period: Timestamp,\n}\n",
        "modules/govern/traits/govern.trait.rs":"pub type ProposalHash = Hash;\n\n#[ink::trait_definition]\npub trait AbaxGovern {\n    /// Propose a `proposal`.\n    ///\n    /// On success emits `ProposalCreated` event.\n    ///\n    /// # Returns\n    ///\n    /// Returns `ProposalId` of the created proposal.\n    ///\n    /// # Errors\n    /// Returns `ProposalAlreadyExists` if `propsal` with the same `proposal_description` exists,\n    /// Returns `InsuficientVotes` if `caller` has insufficient amount of votes to create a proposal.\n    #[ink(message)]\n    fn propose(&mut self, proposal: Proposal) -> Result<ProposalId, GovernError>;\n\n    /// Finilize `proposal_id` if the finalization conditions are met.  \n    ///\n    /// On success emits `ProposalFinalized` event.\n    ///\n    /// # Errors\n    /// Returns `ProposalDoesntExist` if proposal doesn't exist.\n    /// Returns `WrongStatus` if proposal is not `Active``.\n    /// Returns `FinalizeCondition` if finalize condition isn't met.\n    #[ink(message)]\n    fn finalize(&mut self, proposal_id: ProposalId) -> Result<(), GovernError>;\n\n    /// Executes the `proposal` which was finalized with `Succeeded` status.\n    ///\n    /// On success emits `ProposalExecuted` event.\n    ///\n    /// # Errors\n    /// Returns `ProposalDoesntExist` if proposal doesn't exist.\n    /// Returns `WrongStatus` if proposal status is not `Succeeded`.\n    /// Returns `UnderlyingTransactionReverted` if any of Transactions from the `proposal` fails.\n    #[ink(message)]\n    fn execute(&mut self, proposal: Proposal) -> Result<(), GovernError>;\n\n    /// Cast vote in the name of `caller` on `proposa_id` for `vote` with `reason`.\n    ///\n    /// On Success emits `VoteCasted` event.\n    ///\n    /// # Errors\n    /// Returns `InsuficientVotes` if `caller` has no votes.\n    /// Returns `ProposalDoesntExist` if proposal doesn't exist.\n    /// Returns `WrongStatus` if proposal status isn't `Active`.\n    #[ink(message)]\n    fn vote(\n        &mut self,\n        proposal_id: ProposalId,\n        vote: Vote,\n        reason: Vec<u8>,\n    ) -> Result<(), GovernError>;\n\n    /// Forcefully unstakes all tokens of `account` if:\n    /// 1. proposal with `proposal_id` was finalized in Final phase\n    /// 2. `account` has staked some tokens before the proposal was created.\n    ///\n    /// On success emits `ForcefullyUnstaked` event.\n    ///\n    /// # Errors\n    /// Returns `ProposalDoesntExist` if proposal doesn't exist.\n    /// Returns `WrongStatus` if proposal wasn't finalized in final phase.\n    /// Returns `CantForceUnstake` if proposal doesnt allow for force unstake or the 'account' was already force unstaked for not voting on proposal with id >= 'proposal_id'.\n    #[ink(message)]\n    fn force_unstake(\n        &mut self,\n        account: AccountId,\n        proposal_id: ProposalId,\n    ) -> Result<(), GovernError>;\n}\n",
        "modules/govern/traits/govern_internal.trait.rs":"pub trait AbaxGovernInternal {\n    /// Creates new `proposal` with `proposal_id` and `description`\n    ///\n    /// On success emits `ProposalCreated` event.\n    ///\n    /// # Returns\n    ///\n    /// Returns `ProposalId` of the created proposal.\n    ///\n    /// # Errors\n    /// Returns `ProposalAlreadyExists` if `propsal` with the same `proposal_description` exists,\n    fn _propose(\n        &mut self,\n        proposer: &AccountId,\n        proposal: &Proposal,\n    ) -> Result<ProposalId, GovernError>;\n\n    fn _cast_vote(\n        &mut self,\n        voter: &AccountId,\n        proposal_id: ProposalId,\n        vote: Vote,\n        #[allow(unused_variables)] reason: Vec<u8>,\n    ) -> Result<(), GovernError>;\n\n    /// Finalizes proposal identified by `proposal_id`\n    ///\n    /// On success emits `ProposalFinalized` event.\n    ///\n    /// # Errors\n    /// Returns `ProposalDoesntExist` if there is no proposal identified by `proposal_id.\n    /// Returns `NotActive` if proposal identified by `proposal_id` isnt Active.\n    /// Returns `FinalizeCondition` if finalization condition wasn`t met.\n    /// Returns `TransferError` if proposal was finalized with `Succeeded`, `Defeated` and transfering  deposit of native currency to the proposer failed.\n    fn _finalize(&mut self, proposal_id: &ProposalId) -> Result<(), GovernError>;\n\n    /// Executes the `proposal`\n    ///\n    /// On success emits `ProposalExecuted` event.\n    ///\n    /// # Errors\n    /// Returns `ProposalDoesntExist` if there is no proposal identified by `proposal_id.\n    /// Returns `WronfStatus` if proposal identified by `proposal_id` has different than Succeeded status.\n    /// Returns `UnderlyingTransactionReverted` if any of Transactions from the `proposal` fails.\n    fn _execute(&mut self, proposal: &Proposal) -> Result<(), GovernError>;\n\n    /// Forcefully unstakes all tokens of `account` if:\n    /// 1. proposal with `proposal_id` allows for force unstake\n    /// 2. `account` has staked some tokens before the proposal was created.\n    /// 3. `account` hasn't voted one the proposal.\n    ///\n    /// On success emits `ForcefullyUnstaked` event.\n    ///\n    /// # Errors\n    /// Returns `ProposalDoesntExist` if proposal doesn't exist.\n    /// Returns `WrongStatus` if proposal wasn't finalized in final phase.\n    /// Returns `CantForceUnstake` if proposal doesnt allow for force unstake or the 'account' was already force unstaked for not voting on proposal with id >= 'proposal_id'.\n    fn _force_unstake(\n        &mut self,\n        account: &AccountId,\n        proposal_id: &ProposalId,\n    ) -> Result<(), GovernError>;\n}\n",
        "modules/govern/traits/govern_manage.trait.rs":"#[ink::trait_definition]\npub trait AbaxGovernManage {\n    /// change `VotingRules` used for voting\n    ///\n    /// On Success emits `VotingRulesChanged` event.\n    ///\n    /// #Errors\n    ///\n    /// Returns `UnstakeShorterThanVotingPeriod` if the unstake period is shorter than the rules' total voting period.\n    /// Returns `AccessControlError` if the `caller` has not access to the method.\n    #[ink(message)]\n    fn change_voting_rules(&mut self, rules: VotingRules) -> Result<(), GovernError>;\n\n    /// change unstake period\n    ///\n    /// On Success emits `UnstakePeriodChanged` event.\n    ///\n    /// #Errors\n    ///\n    /// Returns `UnstakeShorterThanVotingPeriod` if the `period` is shorter than the total voting period.\n    /// Returns `AccessControlError` if the `caller` has not access to the method.\n    #[ink(message)]\n    fn change_unstake_period(&mut self, period: Timestamp) -> Result<(), GovernError>;\n}\n",
        "modules/govern/traits/govern_view.trait.rs":"#[ink::trait_definition]\npub trait AbaxGovernView {\n    /// Returns account of the vester which is used to unstake tokens.\n    #[ink(message)]\n    fn vester(&self) -> AccountId;\n\n    /// Returns hash of the `proposal`.\n    #[ink(message)]\n    fn hash(&self, proposal: Proposal) -> ProposalHash;\n\n    /// Returns hash of the description.\n    #[ink(message)]\n    fn hash_description(&self, description: String) -> Hash;\n\n    /// Returns hash of the `proposal.\n    #[ink(message)]\n    fn hash_by_id(&self, proposal_id: ProposalId) -> Option<ProposalHash>;\n\n    /// Returns 'VotingRules' used for proposing and voting.\n    #[ink(message)]\n    fn rules(&self) -> VotingRules;\n\n    /// Returns ProposalStatus of proposal with proposal_id (proposal Hash) if it exists.\n    #[ink(message)]\n    fn status(&self, proposal_id: ProposalId) -> Option<ProposalStatus>;\n\n    /// Returns minimum to finalize proposal at current timestamp\n    #[ink(message)]\n    fn minimum_to_finalize(&self, proposal_id: ProposalId) -> Option<Balance>;\n\n    /// Returns ProposalStatus of proposal with proposal_id (proposal Hash) if it exists.\n    #[ink(message)]\n    fn state(&self, proposal_id: ProposalId) -> Option<ProposalState>;\n\n    /// Returns `account` vote for proposal `proposal_id` if it exists.\n    #[ink(message)]\n    fn vote_of_for(&self, account: AccountId, proposal_id: ProposalId) -> Option<UserVote>;\n\n    /// Returns `account` last proposalId that was used for force unstake.\n    #[ink(message)]\n    fn last_force_unstakes(&self, account: AccountId) -> Option<ProposalId>;\n\n    /// Returns last timestamp at which 'account' has staked while having empty stake.\n    #[ink(message)]\n    fn last_stake_timestamp(&self, account: AccountId) -> Option<Timestamp>;\n\n    /// Returns the number of active proposals.\n    #[ink(message)]\n    fn active_proposals(&self) -> u32;\n\n    /// Returns the number of finalized proposals.\n    #[ink(message)]\n    fn finalized_proposals(&self) -> u32;\n\n    /// Returns the number of executed proposals.\n    #[ink(message)]\n    fn executed_proposals(&self) -> u32;\n\n    /// Returns the next proposal id.\n    #[ink(message)]\n    fn next_proposal_id(&self) -> ProposalId;\n\n    /// Returns the `description_url` of the proposal with `proposal_id`.\n    #[ink(message)]\n    fn description_url_by_proposal_id(&self, proposal_id: ProposalId) -> Option<String>;\n\n    /// Returns the `description_hash` of the proposal with `proposal_id`.\n    #[ink(message)]\n    fn description_hash_by_proposal_id(&self, proposal_id: ProposalId) -> Option<Hash>;\n}\n",
        "modules/govern/traits/mod.rs":"pub mod errors;\npub mod events;\npub mod structs;\n\npub use errors::*;\npub use events::*;\npub use structs::*;\n\npub use pendzl::traits::String;\n\npub use ink::{prelude::vec::Vec, primitives::Hash};\n\ninclude!(\"govern.trait.rs\");\ninclude!(\"govern_manage.trait.rs\");\ninclude!(\"govern_view.trait.rs\");\ninclude!(\"govern_internal.trait.rs\");\n",
        "modules/govern/traits/structs/mod.rs":"use ink::primitives::Hash;\npub use pendzl::traits::{AccountId, Balance, Timestamp};\n\npub type ProposalId = u32;\n\ninclude!(\"voting_rules.rs\");\ninclude!(\"proposal_state.rs\");\ninclude!(\"proposal_status.rs\");\ninclude!(\"proposal.rs\");\ninclude!(\"transaction.rs\");\ninclude!(\"user_vote.rs\");\ninclude!(\"vote.rs\");\n",
        "modules/govern/traits/structs/proposal.rs":"use pendzl::traits::String;\n/// A Proposal is what can be proposed\n#[derive(Debug, Clone, PartialEq, scale::Encode, scale::Decode)]\n#[cfg_attr(\n    feature = \"std\",\n    derive(scale_info::TypeInfo, ink::storage::traits::StorageLayout)\n)]\npub struct Proposal {\n    /// Proposed transaction for execution.\n    pub transactions: Vec<Transaction>,\n    pub description_hash: Hash,\n    pub description_url: String,\n    pub earliest_execution: Option<Timestamp>,\n}\n",
        "modules/govern/traits/structs/proposal_state.rs":"#[derive(Debug, Clone, Copy, PartialEq, scale::Encode, scale::Decode)]\n#[cfg_attr(\n    feature = \"std\",\n    derive(scale_info::TypeInfo, ink::storage::traits::StorageLayout)\n)]\npub struct ProposalState {\n    /// proposal status\n    pub status: ProposalStatus,\n    /// if proposal was finalized in final phase, then it's possible to force unstake\n    pub force_unstake_possible: bool,\n    /// the proposer\n    pub proposer: AccountId,\n    /// time of proposition\n    pub start: Timestamp,\n    /// Stake::total_stake at start\n    pub votes_at_start: Balance,\n    /// Stake::counter_stake at start\n    pub counter_at_start: Balance,\n    /// time of proposal finalization. Some if proposal finalized. None if porposal is not finalized yet.\n    pub finalized: Option<Timestamp>,\n    /// amount of votes to accept the proposal\n    pub votes_for: Balance,\n    /// amount of votes to reject proposal\n    pub votes_against: Balance,\n    /// amount of votes to reject proposal and slash the proposer\n    pub votes_against_with_slash: Balance,\n    /// earliest time when proposal can be executed\n    pub earliest_execution: Option<Timestamp>,\n}\n",
        "modules/govern/traits/structs/proposal_status.rs":"#[derive(Debug, Clone, Copy, PartialEq, scale::Encode, scale::Decode)]\n#[cfg_attr(feature = \"std\", derive(scale_info::TypeInfo, ink::storage::traits::StorageLayout))]\npub enum ProposalStatus {\n    /// VotingPeriod\n    Active,\n    /// Reejcted by DAO\n    Defeated,\n    /// Rejected by DAO. Proposer was slashed.\n    DefeatedWithSlash,\n    /// Accepted by DAO. Ready for execution.\n    Succeeded,\n    /// Executed\n    Executed,\n}\n",
        "modules/govern/traits/structs/transaction.rs":"pub use ink::prelude::vec::Vec;\n\n#[derive(Debug, Clone, PartialEq, scale::Encode, scale::Decode)]\n#[cfg_attr(\n    feature = \"std\",\n    derive(scale_info::TypeInfo, ink::storage::traits::StorageLayout)\n)]\npub struct Transaction {\n    /// The `AccountId` of the contract that is called in this transaction.\n    pub callee: AccountId,\n    /// The selector bytes that identifies the function of the callee that should be called.\n    pub selector: [u8; 4],\n    /// The SCALE encoded parameters that are passed to the called function.\n    pub input: Vec<u8>,\n    /// The amount of chain balance that is transferred to the callee.\n    pub transferred_value: Balance,\n}\n\n#[cfg_attr(\n    feature = \"std\",\n    derive(\n        PartialEq,\n        Eq,\n        scale_info::TypeInfo,\n        ink::storage::traits::StorageLayout\n    )\n)]\n#[derive(Clone, Debug)]\npub struct OpaqueTypes(pub Vec<u8>);\n\nimpl scale::Encode for OpaqueTypes {\n    #[inline]\n    fn size_hint(&self) -> usize {\n        self.0.len()\n    }\n\n    #[inline]\n    fn encode_to<O: scale::Output + ?Sized>(&self, output: &mut O) {\n        output.write(&self.0);\n    }\n}\n\nimpl scale::Decode for OpaqueTypes {\n    #[inline]\n    fn decode<I: scale::Input>(input: &mut I) -> Result<Self, scale::Error> {\n        let len = input.remaining_len()?;\n\n        let mut bytes;\n\n        if let Some(len) = len {\n            bytes = ink::prelude::vec![0; len];\n            input.read(&mut bytes[..len])?;\n        } else {\n            bytes = Vec::new();\n            while let Ok(b) = input.read_byte() {\n                bytes.push(b);\n            }\n        };\n\n        Ok(OpaqueTypes(bytes))\n    }\n}\n",
        "modules/govern/traits/structs/user_vote.rs":"#[derive(Debug, Clone, Copy, PartialEq, scale::Encode, scale::Decode)]\n#[cfg_attr(feature = \"std\", derive(scale_info::TypeInfo, ink::storage::traits::StorageLayout))]\npub struct UserVote {\n    /// chosen Vote by user\n    pub vote: Vote,\n    /// amount of votes\n    pub amount: Balance,\n}\n",
        "modules/govern/traits/structs/vote.rs":"#[derive(Debug, Clone, Copy, PartialEq, scale::Encode, scale::Decode)]\n#[cfg_attr(feature = \"std\", derive(scale_info::TypeInfo, ink::storage::traits::StorageLayout))]\n/// Possibilities to choose during voting\npub enum Vote {\n    /// Agree\n    Agreed,\n    /// Disagree\n    Disagreed,\n    /// Disagree and slash the proposal. Should be chosen if the proposition is made to hurt the DAO.\n    DisagreedWithProposerSlashing,\n}\n",
        "modules/govern/traits/structs/voting_rules.rs":"#[derive(Debug, Clone, Copy, PartialEq, scale::Encode, scale::Decode, Default)]\n#[cfg_attr(\n    feature = \"std\",\n    derive(scale_info::TypeInfo, ink::storage::traits::StorageLayout)\n)]\n\npub struct VotingRules {\n    /// minimal part of proposer stake in total stake to propose.\n    pub minimum_stake_part_e3: u16,\n    /// part of total\n    pub proposer_deposit_part_e3: u16,\n    /// during initial period required amount to finalize proposal falls from 100% to 50% of total votes.\n    pub initial_period: Timestamp,\n    /// time after start of proposal during which the required amount to finalize proposal is flat at 50%.\n    pub flat_period: Timestamp,\n    /// time after flat_period during which the required amount to finalize proposal linearly falls to 0.\n    pub final_period: Timestamp,\n}\n",
        "modules/mod.rs":"pub mod govern;\n"
    },
    "manifest-path":"Cargo.toml"
}
