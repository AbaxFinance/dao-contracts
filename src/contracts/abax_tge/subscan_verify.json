{
    "contracts":{
        "Cargo.lock":"# This file is automatically @generated by Cargo.\n# It is not intended for manual editing.\nversion = 3\n\n[[package]]\nname = \"abax_tge\"\nversion = \"1.0.0\"\ndependencies = [\n \"ink\",\n \"parity-scale-codec\",\n \"pendzl\",\n \"primitive-types\",\n \"scale-info\",\n]\n\n[[package]]\nname = \"aead\"\nversion = \"0.5.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"d122413f284cf2d62fb1b7db97e02edb8cda96d769b16e443a4f6195e35662b0\"\ndependencies = [\n \"crypto-common\",\n \"generic-array\",\n]\n\n[[package]]\nname = \"array-init\"\nversion = \"2.1.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"3d62b7694a562cdf5a74227903507c56ab2cc8bdd1f781ed5cb4cf9c9f810bfc\"\n\n[[package]]\nname = \"arrayref\"\nversion = \"0.3.7\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"6b4930d2cb77ce62f89ee5d5289b4ac049559b1c45539271f5ed4fdc7db34545\"\n\n[[package]]\nname = \"arrayvec\"\nversion = \"0.7.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"96d30a06541fbafbc7f82ed10c06164cfbd2c401138f6addd8404629c4b16711\"\n\n[[package]]\nname = \"autocfg\"\nversion = \"1.1.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"d468802bab17cbc0cc575e9b053f41e72aa36bfa6b7f55e3529ffa43161b97fa\"\n\n[[package]]\nname = \"bitflags\"\nversion = \"1.3.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a\"\n\n[[package]]\nname = \"bitvec\"\nversion = \"1.0.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"1bc2832c24239b0141d5674bb9174f9d68a8b5b3f2753311927c172ca46f7e9c\"\ndependencies = [\n \"funty\",\n \"radium\",\n \"tap\",\n \"wyz\",\n]\n\n[[package]]\nname = \"blake2\"\nversion = \"0.10.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"46502ad458c9a52b69d4d4d32775c788b7a1b85e8bc9d482d92250fc0e3f8efe\"\ndependencies = [\n \"digest\",\n]\n\n[[package]]\nname = \"block-buffer\"\nversion = \"0.10.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"3078c7629b62d3f0439517fa394996acacc5cbc91c5a20d8c658e77abd503a71\"\ndependencies = [\n \"generic-array\",\n]\n\n[[package]]\nname = \"byte-slice-cast\"\nversion = \"1.2.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"c3ac9f8b63eca6fd385229b3675f6cc0dc5c8a5c8a54a59d4f52ffd670d87b0c\"\n\n[[package]]\nname = \"byteorder\"\nversion = \"1.5.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"1fd0f2584146f6f2ef48085050886acf353beff7305ebd1ae69500e27c67f64b\"\n\n[[package]]\nname = \"camino\"\nversion = \"1.1.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"c59e92b5a388f549b863a7bea62612c09f24c8393560709a54558a9abdfb3b9c\"\ndependencies = [\n \"serde\",\n]\n\n[[package]]\nname = \"cargo-platform\"\nversion = \"0.1.7\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"694c8807f2ae16faecc43dc17d74b3eb042482789fd0eb64b39a2e04e087053f\"\ndependencies = [\n \"serde\",\n]\n\n[[package]]\nname = \"cargo_metadata\"\nversion = \"0.13.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"081e3f0755c1f380c2d010481b6fa2e02973586d5f2b24eebb7a2a1d98b143d8\"\ndependencies = [\n \"camino\",\n \"cargo-platform\",\n \"semver 0.11.0\",\n \"semver-parser\",\n \"serde\",\n \"serde_json\",\n]\n\n[[package]]\nname = \"cc\"\nversion = \"1.0.90\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"8cd6604a82acf3039f1144f54b8eb34e91ffba622051189e71b781822d5ee1f5\"\n\n[[package]]\nname = \"cfg-if\"\nversion = \"1.0.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n\n[[package]]\nname = \"const_env\"\nversion = \"0.1.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"3e9e4f72c6e3398ca6da372abd9affd8f89781fe728869bbf986206e9af9627e\"\ndependencies = [\n \"const_env_impl\",\n]\n\n[[package]]\nname = \"const_env_impl\"\nversion = \"0.1.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"3a4f51209740b5e1589e702b3044cdd4562cef41b6da404904192ffffb852d62\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"syn 1.0.109\",\n]\n\n[[package]]\nname = \"const_format\"\nversion = \"0.2.32\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"e3a214c7af3d04997541b18d432afaff4c455e79e2029079647e72fc2bd27673\"\ndependencies = [\n \"const_format_proc_macros\",\n]\n\n[[package]]\nname = \"const_format_proc_macros\"\nversion = \"0.2.32\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"c7f6ff08fd20f4f299298a28e2dfa8a8ba1036e6cd2460ac1de7b425d76f2500\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"unicode-xid\",\n]\n\n[[package]]\nname = \"cpufeatures\"\nversion = \"0.2.12\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"53fe5e26ff1b7aef8bca9c6080520cfb8d9333c7568e1829cef191a9723e5504\"\ndependencies = [\n \"libc\",\n]\n\n[[package]]\nname = \"crunchy\"\nversion = \"0.2.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"7a81dae078cea95a014a339291cec439d2f232ebe854a9d672b796c6afafa9b7\"\n\n[[package]]\nname = \"crypto-common\"\nversion = \"0.1.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"1bfb12502f3fc46cca1bb51ac28df9d618d813cdc3d2f25b9fe775a34af26bb3\"\ndependencies = [\n \"generic-array\",\n \"rand_core\",\n \"typenum\",\n]\n\n[[package]]\nname = \"curve25519-dalek\"\nversion = \"4.1.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"0a677b8922c94e01bdbb12126b0bc852f00447528dee1782229af9c720c3f348\"\ndependencies = [\n \"cfg-if\",\n \"cpufeatures\",\n \"curve25519-dalek-derive\",\n \"digest\",\n \"fiat-crypto\",\n \"platforms\",\n \"rustc_version\",\n \"subtle\",\n \"zeroize\",\n]\n\n[[package]]\nname = \"curve25519-dalek-derive\"\nversion = \"0.1.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"f46882e17999c6cc590af592290432be3bce0428cb0d5f8b6715e4dc7b383eb3\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"syn 2.0.53\",\n]\n\n[[package]]\nname = \"darling\"\nversion = \"0.14.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"7b750cb3417fd1b327431a470f388520309479ab0bf5e323505daf0290cd3850\"\ndependencies = [\n \"darling_core\",\n \"darling_macro\",\n]\n\n[[package]]\nname = \"darling_core\"\nversion = \"0.14.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"109c1ca6e6b7f82cc233a97004ea8ed7ca123a9af07a8230878fcfda9b158bf0\"\ndependencies = [\n \"fnv\",\n \"ident_case\",\n \"proc-macro2\",\n \"quote\",\n \"strsim\",\n \"syn 1.0.109\",\n]\n\n[[package]]\nname = \"darling_macro\"\nversion = \"0.14.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"a4aab4dbc9f7611d8b55048a3a16d2d010c2c8334e46304b40ac1cc14bf3b48e\"\ndependencies = [\n \"darling_core\",\n \"quote\",\n \"syn 1.0.109\",\n]\n\n[[package]]\nname = \"derive_more\"\nversion = \"0.99.17\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"4fb810d30a7c1953f91334de7244731fc3f3c10d7fe163338a35b9f640960321\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"syn 1.0.109\",\n]\n\n[[package]]\nname = \"digest\"\nversion = \"0.10.7\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"9ed9a281f7bc9b7576e61468ba615a66a5c8cfdff42420a70aa82701a3b1e292\"\ndependencies = [\n \"block-buffer\",\n \"crypto-common\",\n \"subtle\",\n]\n\n[[package]]\nname = \"dyn-clone\"\nversion = \"1.0.17\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"0d6ef0072f8a535281e4876be788938b528e9a1d43900b82c2569af7da799125\"\n\n[[package]]\nname = \"either\"\nversion = \"1.10.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"11157ac094ffbdde99aa67b23417ebdd801842852b500e395a45a9c0aac03e4a\"\n\n[[package]]\nname = \"equivalent\"\nversion = \"1.0.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"5443807d6dff69373d433ab9ef5378ad8df50ca6298caf15de6e52e24aaf54d5\"\n\n[[package]]\nname = \"ethnum\"\nversion = \"1.5.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"b90ca2580b73ab6a1f724b76ca11ab632df820fd6040c336200d2c1df7b3c82c\"\n\n[[package]]\nname = \"fiat-crypto\"\nversion = \"0.2.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"1676f435fc1dadde4d03e43f5d62b259e1ce5f40bd4ffb21db2b42ebe59c1382\"\n\n[[package]]\nname = \"fixed-hash\"\nversion = \"0.8.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"835c052cb0c08c1acf6ffd71c022172e18723949c8282f2b9f27efbc51e64534\"\ndependencies = [\n \"byteorder\",\n \"rand\",\n \"rustc-hex\",\n \"static_assertions\",\n]\n\n[[package]]\nname = \"fnv\"\nversion = \"1.0.7\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"3f9eec918d3f24069decb9af1554cad7c880e2da24a9afd88aca000531ab82c1\"\n\n[[package]]\nname = \"fs2\"\nversion = \"0.4.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"9564fc758e15025b46aa6643b1b77d047d1a56a1aea6e01002ac0c7026876213\"\ndependencies = [\n \"libc\",\n \"winapi\",\n]\n\n[[package]]\nname = \"funty\"\nversion = \"2.0.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"e6d5a32815ae3f33302d95fdcb2ce17862f8c65363dcfd29360480ba1001fc9c\"\n\n[[package]]\nname = \"generic-array\"\nversion = \"0.14.7\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"85649ca51fd72272d7821adaf274ad91c288277713d9c18820d8499a7ff69e9a\"\ndependencies = [\n \"typenum\",\n \"version_check\",\n]\n\n[[package]]\nname = \"getrandom\"\nversion = \"0.2.12\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"190092ea657667030ac6a35e305e62fc4dd69fd98ac98631e5d3a2b1575a12b5\"\ndependencies = [\n \"cfg-if\",\n \"libc\",\n \"wasi\",\n]\n\n[[package]]\nname = \"getrandom_or_panic\"\nversion = \"0.0.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"6ea1015b5a70616b688dc230cfe50c8af89d972cb132d5a622814d29773b10b9\"\ndependencies = [\n \"rand\",\n \"rand_core\",\n]\n\n[[package]]\nname = \"hashbrown\"\nversion = \"0.14.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"290f1a1d9242c78d09ce40a5e87e7554ee637af1351968159f4952f028f75604\"\n\n[[package]]\nname = \"heck\"\nversion = \"0.3.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"6d621efb26863f0e9924c6ac577e8275e5e6b77455db64ffa6c65c904e9e132c\"\ndependencies = [\n \"unicode-segmentation\",\n]\n\n[[package]]\nname = \"heck\"\nversion = \"0.4.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"95505c38b4572b2d910cecb0281560f54b440a19336cbbcb27bf6ce6adc6f5a8\"\n\n[[package]]\nname = \"hex\"\nversion = \"0.4.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"7f24254aa9a54b5c858eaee2f5bccdb46aaf0e486a595ed5fd8f86ba55232a70\"\n\n[[package]]\nname = \"ident_case\"\nversion = \"1.0.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"b9e0384b61958566e926dc50660321d12159025e767c18e043daf26b70104c39\"\n\n[[package]]\nname = \"impl-codec\"\nversion = \"0.6.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"ba6a270039626615617f3f36d15fc827041df3b78c439da2cadfa47455a77f2f\"\ndependencies = [\n \"parity-scale-codec\",\n]\n\n[[package]]\nname = \"impl-serde\"\nversion = \"0.4.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"ebc88fc67028ae3db0c853baa36269d398d5f45b6982f95549ff5def78c935cd\"\ndependencies = [\n \"serde\",\n]\n\n[[package]]\nname = \"impl-trait-for-tuples\"\nversion = \"0.2.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"11d7a9f6330b71fea57921c9b61c47ee6e84f72d394754eff6163ae67e7395eb\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"syn 1.0.109\",\n]\n\n[[package]]\nname = \"indexmap\"\nversion = \"2.2.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"7b0b929d511467233429c45a44ac1dcaa21ba0f5ba11e4879e6ed28ddb4f9df4\"\ndependencies = [\n \"equivalent\",\n \"hashbrown\",\n]\n\n[[package]]\nname = \"ink\"\nversion = \"5.0.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"3d4a862aedbfda93175ddf75c9aaa2ae4c4b39ee5cee06c16d50bccce05bf5c7\"\ndependencies = [\n \"derive_more\",\n \"ink_env\",\n \"ink_macro\",\n \"ink_metadata\",\n \"ink_prelude 5.0.0\",\n \"ink_primitives 5.0.0\",\n \"ink_storage\",\n \"pallet-contracts-uapi-next\",\n \"parity-scale-codec\",\n \"scale-info\",\n]\n\n[[package]]\nname = \"ink_allocator\"\nversion = \"5.0.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"5cee56055bac6d928d425e944c5f3b69baa33c9635822fd1c00cd4afc70fde3e\"\ndependencies = [\n \"cfg-if\",\n]\n\n[[package]]\nname = \"ink_codegen\"\nversion = \"5.0.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"70a1f8473fa09e0f9b6f3cb3f8d18c07c14ebf9ea1f7cdfee270f009d45ee8e9\"\ndependencies = [\n \"blake2\",\n \"derive_more\",\n \"either\",\n \"heck 0.4.1\",\n \"impl-serde\",\n \"ink_ir 5.0.0\",\n \"ink_primitives 5.0.0\",\n \"itertools 0.12.1\",\n \"parity-scale-codec\",\n \"proc-macro2\",\n \"quote\",\n \"serde\",\n \"serde_json\",\n \"syn 2.0.53\",\n]\n\n[[package]]\nname = \"ink_engine\"\nversion = \"5.0.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"4f357e2e867f4e222ffc4015a6e61d1073548de89f70a4e36a8b0385562777fa\"\ndependencies = [\n \"blake2\",\n \"derive_more\",\n \"ink_primitives 5.0.0\",\n \"pallet-contracts-uapi-next\",\n \"parity-scale-codec\",\n \"secp256k1\",\n \"sha2\",\n \"sha3\",\n]\n\n[[package]]\nname = \"ink_env\"\nversion = \"5.0.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"42cec50b7e4f8406aab25801b015d3802a52d76cfbe48ce11cfb4200fa88e296\"\ndependencies = [\n \"blake2\",\n \"cfg-if\",\n \"const_env\",\n \"derive_more\",\n \"ink_allocator\",\n \"ink_engine\",\n \"ink_prelude 5.0.0\",\n \"ink_primitives 5.0.0\",\n \"ink_storage_traits\",\n \"num-traits\",\n \"pallet-contracts-uapi-next\",\n \"parity-scale-codec\",\n \"paste\",\n \"rlibc\",\n \"scale-decode\",\n \"scale-encode\",\n \"scale-info\",\n \"schnorrkel\",\n \"secp256k1\",\n \"sha2\",\n \"sha3\",\n \"static_assertions\",\n]\n\n[[package]]\nname = \"ink_ir\"\nversion = \"4.3.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"5b529c941518e8f450395fab9fe8ebba0a7acbb18778fc7e0a87f6248286ec72\"\ndependencies = [\n \"blake2\",\n \"either\",\n \"itertools 0.10.5\",\n \"proc-macro2\",\n \"quote\",\n \"syn 2.0.53\",\n]\n\n[[package]]\nname = \"ink_ir\"\nversion = \"5.0.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"3b1ad2975551c4ed800af971289ed6d2c68ac41ffc03a42010b3e01d7360dfb2\"\ndependencies = [\n \"blake2\",\n \"either\",\n \"impl-serde\",\n \"ink_prelude 5.0.0\",\n \"itertools 0.12.1\",\n \"proc-macro2\",\n \"quote\",\n \"syn 2.0.53\",\n]\n\n[[package]]\nname = \"ink_macro\"\nversion = \"5.0.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"aee1a546f37eae3b3cd223832d31702033c5369dcfa3405899587c110a7908d3\"\ndependencies = [\n \"ink_codegen\",\n \"ink_ir 5.0.0\",\n \"ink_primitives 5.0.0\",\n \"parity-scale-codec\",\n \"proc-macro2\",\n \"quote\",\n \"syn 2.0.53\",\n \"synstructure 0.13.1\",\n]\n\n[[package]]\nname = \"ink_metadata\"\nversion = \"5.0.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"a98fcc0ff9292ff68c7ee7b84c93533c9ff13859ec3b148faa822e2da9954fe6\"\ndependencies = [\n \"derive_more\",\n \"impl-serde\",\n \"ink_prelude 5.0.0\",\n \"ink_primitives 5.0.0\",\n \"linkme\",\n \"parity-scale-codec\",\n \"scale-info\",\n \"schemars\",\n \"serde\",\n]\n\n[[package]]\nname = \"ink_prelude\"\nversion = \"4.3.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"d8cfdf91d2b442f08efb34dd3780fd6fbd3d033f63b42f62684fe47534948ef6\"\ndependencies = [\n \"cfg-if\",\n]\n\n[[package]]\nname = \"ink_prelude\"\nversion = \"5.0.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"ea1734d058c80aa72e59c8ae75624fd8a51791efba21469f273156c0f4cad5c9\"\ndependencies = [\n \"cfg-if\",\n]\n\n[[package]]\nname = \"ink_primitives\"\nversion = \"4.3.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"6414bcad12ebf0c3abbbb192a09e4d06e22f662cf3e19545204e1b0684be12a1\"\ndependencies = [\n \"derive_more\",\n \"ink_prelude 4.3.0\",\n \"parity-scale-codec\",\n \"xxhash-rust\",\n]\n\n[[package]]\nname = \"ink_primitives\"\nversion = \"5.0.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"11ec35ef7f45e67a53b6142d7e7f18e6d9292d76c3a2a1da14cf8423e481813d\"\ndependencies = [\n \"derive_more\",\n \"ink_prelude 5.0.0\",\n \"parity-scale-codec\",\n \"scale-decode\",\n \"scale-encode\",\n \"scale-info\",\n \"xxhash-rust\",\n]\n\n[[package]]\nname = \"ink_storage\"\nversion = \"5.0.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"bbdb04cad74df858c05bc9cb6f30bbf12da33c3e2cb7ca211749c001fa761aa9\"\ndependencies = [\n \"array-init\",\n \"cfg-if\",\n \"derive_more\",\n \"ink_env\",\n \"ink_metadata\",\n \"ink_prelude 5.0.0\",\n \"ink_primitives 5.0.0\",\n \"ink_storage_traits\",\n \"pallet-contracts-uapi-next\",\n \"parity-scale-codec\",\n \"scale-info\",\n]\n\n[[package]]\nname = \"ink_storage_traits\"\nversion = \"5.0.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"83ce49e3d2935fc1ec3e73117119712b187d3123339f6a31624e92f75fa2293d\"\ndependencies = [\n \"ink_metadata\",\n \"ink_prelude 5.0.0\",\n \"ink_primitives 5.0.0\",\n \"parity-scale-codec\",\n \"scale-info\",\n]\n\n[[package]]\nname = \"itertools\"\nversion = \"0.10.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"b0fd2260e829bddf4cb6ea802289de2f86d6a7a690192fbe91b3f46e0f2c8473\"\ndependencies = [\n \"either\",\n]\n\n[[package]]\nname = \"itertools\"\nversion = \"0.12.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"ba291022dbbd398a455acf126c1e341954079855bc60dfdda641363bd6922569\"\ndependencies = [\n \"either\",\n]\n\n[[package]]\nname = \"itoa\"\nversion = \"1.0.10\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"b1a46d1a171d865aa5f83f92695765caa047a9b4cbae2cbf37dbd613a793fd4c\"\n\n[[package]]\nname = \"keccak\"\nversion = \"0.1.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"ecc2af9a1119c51f12a14607e783cb977bde58bc069ff0c3da1095e635d70654\"\ndependencies = [\n \"cpufeatures\",\n]\n\n[[package]]\nname = \"libc\"\nversion = \"0.2.153\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"9c198f91728a82281a64e1f4f9eeb25d82cb32a5de251c6bd1b5154d63a8e7bd\"\n\n[[package]]\nname = \"linkme\"\nversion = \"0.3.25\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"bb2cfee0de9bd869589fb9a015e155946d1be5ff415cb844c2caccc6cc4b5db9\"\ndependencies = [\n \"linkme-impl\",\n]\n\n[[package]]\nname = \"linkme-impl\"\nversion = \"0.3.25\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"adf157a4dc5a29b7b464aa8fe7edeff30076e07e13646a1c3874f58477dc99f8\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"syn 2.0.53\",\n]\n\n[[package]]\nname = \"memchr\"\nversion = \"2.7.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"523dc4f511e55ab87b694dc30d0f820d60906ef06413f93d4d7a1385599cc149\"\n\n[[package]]\nname = \"merlin\"\nversion = \"3.0.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"58c38e2799fc0978b65dfff8023ec7843e2330bb462f19198840b34b6582397d\"\ndependencies = [\n \"byteorder\",\n \"keccak\",\n \"rand_core\",\n \"zeroize\",\n]\n\n[[package]]\nname = \"num-traits\"\nversion = \"0.2.18\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"da0df0e5185db44f69b44f26786fe401b6c293d1907744beaa7fa62b2e5a517a\"\ndependencies = [\n \"autocfg\",\n]\n\n[[package]]\nname = \"once_cell\"\nversion = \"1.19.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"3fdb12b2476b595f9358c5161aa467c2438859caa136dec86c26fdd2efe17b92\"\n\n[[package]]\nname = \"pallet-contracts-uapi-next\"\nversion = \"6.0.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"fd549c16296ea5b2eb7c65c56aba548b286c1be4d7675b424ff6ccb8319c97a9\"\ndependencies = [\n \"bitflags\",\n \"paste\",\n \"polkavm-derive\",\n]\n\n[[package]]\nname = \"parity-scale-codec\"\nversion = \"3.6.9\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"881331e34fa842a2fb61cc2db9643a8fedc615e47cfcc52597d1af0db9a7e8fe\"\ndependencies = [\n \"arrayvec\",\n \"bitvec\",\n \"byte-slice-cast\",\n \"impl-trait-for-tuples\",\n \"parity-scale-codec-derive\",\n \"serde\",\n]\n\n[[package]]\nname = \"parity-scale-codec-derive\"\nversion = \"3.6.9\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"be30eaf4b0a9fba5336683b38de57bb86d179a35862ba6bfcf57625d006bde5b\"\ndependencies = [\n \"proc-macro-crate 2.0.2\",\n \"proc-macro2\",\n \"quote\",\n \"syn 1.0.109\",\n]\n\n[[package]]\nname = \"paste\"\nversion = \"1.0.14\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"de3145af08024dea9fa9914f381a17b8fc6034dfb00f3a84013f7ff43f29ed4c\"\n\n[[package]]\nname = \"pendzl\"\nversion = \"1.0.1-v1calls\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"7c79ba487736e2475e44ec917040cd87dc4ba9f27fddb8c95f4bf130b4ac6a65\"\ndependencies = [\n \"ink\",\n \"parity-scale-codec\",\n \"pendzl_contracts\",\n \"pendzl_lang\",\n \"scale-info\",\n]\n\n[[package]]\nname = \"pendzl_contracts\"\nversion = \"1.0.1-v1calls\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"ab692839aad45923200968ff94a3c64595f6a17f1059ae3d0e363a80a4837699\"\ndependencies = [\n \"hex\",\n \"ink\",\n \"parity-scale-codec\",\n \"pendzl_lang\",\n \"scale-info\",\n]\n\n[[package]]\nname = \"pendzl_lang\"\nversion = \"1.0.1-v1calls\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"df579ab11b77f1efacff5f4dea408927c264ad903de994b929206f3885832be7\"\ndependencies = [\n \"const_format\",\n \"ethnum\",\n \"ink\",\n \"parity-scale-codec\",\n \"pendzl_lang_macro\",\n \"scale-info\",\n \"xxhash-rust\",\n]\n\n[[package]]\nname = \"pendzl_lang_codegen\"\nversion = \"1.0.1-v1calls\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"3217fddc39db986a85aff5da5448bd2d6c296d93e51a8d267cbe26cb47f8dc5e\"\ndependencies = [\n \"blake2\",\n \"cargo_metadata\",\n \"fs2\",\n \"heck 0.3.3\",\n \"ink_ir 4.3.0\",\n \"ink_primitives 4.3.0\",\n \"proc-macro2\",\n \"quote\",\n \"serde\",\n \"serde_json\",\n \"syn 1.0.109\",\n \"synstructure 0.12.6\",\n \"unwrap\",\n]\n\n[[package]]\nname = \"pendzl_lang_macro\"\nversion = \"1.0.1-v1calls\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"680746c3225b7b0fadd7aa78a6fca44589ba16591a6a6889488110f5033888eb\"\ndependencies = [\n \"pendzl_lang_codegen\",\n \"proc-macro2\",\n \"syn 1.0.109\",\n \"synstructure 0.12.6\",\n]\n\n[[package]]\nname = \"pest\"\nversion = \"2.7.8\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"56f8023d0fb78c8e03784ea1c7f3fa36e68a723138990b8d5a47d916b651e7a8\"\ndependencies = [\n \"memchr\",\n \"thiserror\",\n \"ucd-trie\",\n]\n\n[[package]]\nname = \"platforms\"\nversion = \"3.3.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"626dec3cac7cc0e1577a2ec3fc496277ec2baa084bebad95bb6fdbfae235f84c\"\n\n[[package]]\nname = \"polkavm-common\"\nversion = \"0.5.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"88b4e215c80fe876147f3d58158d5dfeae7dabdd6047e175af77095b78d0035c\"\n\n[[package]]\nname = \"polkavm-derive\"\nversion = \"0.5.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"6380dbe1fb03ecc74ad55d841cfc75480222d153ba69ddcb00977866cbdabdb8\"\ndependencies = [\n \"polkavm-derive-impl\",\n \"syn 2.0.53\",\n]\n\n[[package]]\nname = \"polkavm-derive-impl\"\nversion = \"0.5.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"dc8211b3365bbafb2fb32057d68b0e1ca55d079f5cf6f9da9b98079b94b3987d\"\ndependencies = [\n \"polkavm-common\",\n \"proc-macro2\",\n \"quote\",\n \"syn 2.0.53\",\n]\n\n[[package]]\nname = \"ppv-lite86\"\nversion = \"0.2.17\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"5b40af805b3121feab8a3c29f04d8ad262fa8e0561883e7653e024ae4479e6de\"\n\n[[package]]\nname = \"primitive-types\"\nversion = \"0.12.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"0b34d9fd68ae0b74a41b21c03c2f62847aa0ffea044eee893b4c140b37e244e2\"\ndependencies = [\n \"fixed-hash\",\n \"impl-codec\",\n \"scale-info\",\n \"uint\",\n]\n\n[[package]]\nname = \"proc-macro-crate\"\nversion = \"1.3.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"7f4c021e1093a56626774e81216a4ce732a735e5bad4868a03f3ed65ca0c3919\"\ndependencies = [\n \"once_cell\",\n \"toml_edit 0.19.15\",\n]\n\n[[package]]\nname = \"proc-macro-crate\"\nversion = \"2.0.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"b00f26d3400549137f92511a46ac1cd8ce37cb5598a96d382381458b992a5d24\"\ndependencies = [\n \"toml_datetime\",\n \"toml_edit 0.20.2\",\n]\n\n[[package]]\nname = \"proc-macro2\"\nversion = \"1.0.79\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"e835ff2298f5721608eb1a980ecaee1aef2c132bf95ecc026a11b7bf3c01c02e\"\ndependencies = [\n \"unicode-ident\",\n]\n\n[[package]]\nname = \"quote\"\nversion = \"1.0.35\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"291ec9ab5efd934aaf503a6466c5d5251535d108ee747472c3977cc5acc868ef\"\ndependencies = [\n \"proc-macro2\",\n]\n\n[[package]]\nname = \"radium\"\nversion = \"0.7.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"dc33ff2d4973d518d823d61aa239014831e521c75da58e3df4840d3f47749d09\"\n\n[[package]]\nname = \"rand\"\nversion = \"0.8.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"34af8d1a0e25924bc5b7c43c079c942339d8f0a8b57c39049bef581b46327404\"\ndependencies = [\n \"libc\",\n \"rand_chacha\",\n \"rand_core\",\n]\n\n[[package]]\nname = \"rand_chacha\"\nversion = \"0.3.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"e6c10a63a0fa32252be49d21e7709d4d4baf8d231c2dbce1eaa8141b9b127d88\"\ndependencies = [\n \"ppv-lite86\",\n \"rand_core\",\n]\n\n[[package]]\nname = \"rand_core\"\nversion = \"0.6.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"ec0be4795e2f6a28069bec0b5ff3e2ac9bafc99e6a9a7dc3547996c5c816922c\"\ndependencies = [\n \"getrandom\",\n]\n\n[[package]]\nname = \"rlibc\"\nversion = \"1.0.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"fc874b127765f014d792f16763a81245ab80500e2ad921ed4ee9e82481ee08fe\"\n\n[[package]]\nname = \"rustc-hex\"\nversion = \"2.1.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"3e75f6a532d0fd9f7f13144f392b6ad56a32696bfcd9c78f797f16bbb6f072d6\"\n\n[[package]]\nname = \"rustc_version\"\nversion = \"0.4.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"bfa0f585226d2e68097d4f95d113b15b83a82e819ab25717ec0590d9584ef366\"\ndependencies = [\n \"semver 1.0.22\",\n]\n\n[[package]]\nname = \"ryu\"\nversion = \"1.0.17\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"e86697c916019a8588c99b5fac3cead74ec0b4b819707a682fd4d23fa0ce1ba1\"\n\n[[package]]\nname = \"scale-bits\"\nversion = \"0.4.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"036575c29af9b6e4866ffb7fa055dbf623fe7a9cc159b33786de6013a6969d89\"\ndependencies = [\n \"parity-scale-codec\",\n \"scale-info\",\n]\n\n[[package]]\nname = \"scale-decode\"\nversion = \"0.10.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"7caaf753f8ed1ab4752c6afb20174f03598c664724e0e32628e161c21000ff76\"\ndependencies = [\n \"derive_more\",\n \"parity-scale-codec\",\n \"scale-bits\",\n \"scale-decode-derive\",\n \"scale-info\",\n \"smallvec\",\n]\n\n[[package]]\nname = \"scale-decode-derive\"\nversion = \"0.10.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"d3475108a1b62c7efd1b5c65974f30109a598b2f45f23c9ae030acb9686966db\"\ndependencies = [\n \"darling\",\n \"proc-macro-crate 1.3.1\",\n \"proc-macro2\",\n \"quote\",\n \"syn 1.0.109\",\n]\n\n[[package]]\nname = \"scale-encode\"\nversion = \"0.5.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"6d70cb4b29360105483fac1ed567ff95d65224a14dd275b6303ed0a654c78de5\"\ndependencies = [\n \"derive_more\",\n \"parity-scale-codec\",\n \"scale-encode-derive\",\n \"scale-info\",\n \"smallvec\",\n]\n\n[[package]]\nname = \"scale-encode-derive\"\nversion = \"0.5.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"995491f110efdc6bea96d6a746140e32bfceb4ea47510750a5467295a4707a25\"\ndependencies = [\n \"darling\",\n \"proc-macro-crate 1.3.1\",\n \"proc-macro2\",\n \"quote\",\n \"syn 1.0.109\",\n]\n\n[[package]]\nname = \"scale-info\"\nversion = \"2.11.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"2ef2175c2907e7c8bc0a9c3f86aeb5ec1f3b275300ad58a44d0c3ae379a5e52e\"\ndependencies = [\n \"bitvec\",\n \"cfg-if\",\n \"derive_more\",\n \"parity-scale-codec\",\n \"scale-info-derive\",\n \"schemars\",\n \"serde\",\n]\n\n[[package]]\nname = \"scale-info-derive\"\nversion = \"2.11.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"634d9b8eb8fd61c5cdd3390d9b2132300a7e7618955b98b8416f118c1b4e144f\"\ndependencies = [\n \"proc-macro-crate 1.3.1\",\n \"proc-macro2\",\n \"quote\",\n \"syn 1.0.109\",\n]\n\n[[package]]\nname = \"schemars\"\nversion = \"0.8.16\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"45a28f4c49489add4ce10783f7911893516f15afe45d015608d41faca6bc4d29\"\ndependencies = [\n \"dyn-clone\",\n \"schemars_derive\",\n \"serde\",\n \"serde_json\",\n]\n\n[[package]]\nname = \"schemars_derive\"\nversion = \"0.8.16\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"c767fd6fa65d9ccf9cf026122c1b555f2ef9a4f0cea69da4d7dbc3e258d30967\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"serde_derive_internals\",\n \"syn 1.0.109\",\n]\n\n[[package]]\nname = \"schnorrkel\"\nversion = \"0.11.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"8de18f6d8ba0aad7045f5feae07ec29899c1112584a38509a84ad7b04451eaa0\"\ndependencies = [\n \"aead\",\n \"arrayref\",\n \"arrayvec\",\n \"curve25519-dalek\",\n \"getrandom_or_panic\",\n \"merlin\",\n \"rand_core\",\n \"serde_bytes\",\n \"sha2\",\n \"subtle\",\n \"zeroize\",\n]\n\n[[package]]\nname = \"secp256k1\"\nversion = \"0.28.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"d24b59d129cdadea20aea4fb2352fa053712e5d713eee47d700cd4b2bc002f10\"\ndependencies = [\n \"secp256k1-sys\",\n]\n\n[[package]]\nname = \"secp256k1-sys\"\nversion = \"0.9.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"e5d1746aae42c19d583c3c1a8c646bfad910498e2051c551a7f2e3c0c9fbb7eb\"\ndependencies = [\n \"cc\",\n]\n\n[[package]]\nname = \"semver\"\nversion = \"0.11.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"f301af10236f6df4160f7c3f04eec6dbc70ace82d23326abad5edee88801c6b6\"\ndependencies = [\n \"semver-parser\",\n \"serde\",\n]\n\n[[package]]\nname = \"semver\"\nversion = \"1.0.22\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"92d43fe69e652f3df9bdc2b85b2854a0825b86e4fb76bc44d945137d053639ca\"\n\n[[package]]\nname = \"semver-parser\"\nversion = \"0.10.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"00b0bef5b7f9e0df16536d3961cfb6e84331c065b4066afb39768d0e319411f7\"\ndependencies = [\n \"pest\",\n]\n\n[[package]]\nname = \"serde\"\nversion = \"1.0.197\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"3fb1c873e1b9b056a4dc4c0c198b24c3ffa059243875552b2bd0933b1aee4ce2\"\ndependencies = [\n \"serde_derive\",\n]\n\n[[package]]\nname = \"serde_bytes\"\nversion = \"0.11.14\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"8b8497c313fd43ab992087548117643f6fcd935cbf36f176ffda0aacf9591734\"\ndependencies = [\n \"serde\",\n]\n\n[[package]]\nname = \"serde_derive\"\nversion = \"1.0.197\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"7eb0b34b42edc17f6b7cac84a52a1c5f0e1bb2227e997ca9011ea3dd34e8610b\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"syn 2.0.53\",\n]\n\n[[package]]\nname = \"serde_derive_internals\"\nversion = \"0.26.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"85bf8229e7920a9f636479437026331ce11aa132b4dde37d121944a44d6e5f3c\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"syn 1.0.109\",\n]\n\n[[package]]\nname = \"serde_json\"\nversion = \"1.0.114\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"c5f09b1bd632ef549eaa9f60a1f8de742bdbc698e6cee2095fc84dde5f549ae0\"\ndependencies = [\n \"itoa\",\n \"ryu\",\n \"serde\",\n]\n\n[[package]]\nname = \"sha2\"\nversion = \"0.10.8\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"793db75ad2bcafc3ffa7c68b215fee268f537982cd901d132f89c6343f3a3dc8\"\ndependencies = [\n \"cfg-if\",\n \"cpufeatures\",\n \"digest\",\n]\n\n[[package]]\nname = \"sha3\"\nversion = \"0.10.8\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"75872d278a8f37ef87fa0ddbda7802605cb18344497949862c0d4dcb291eba60\"\ndependencies = [\n \"digest\",\n \"keccak\",\n]\n\n[[package]]\nname = \"smallvec\"\nversion = \"1.13.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"e6ecd384b10a64542d77071bd64bd7b231f4ed5940fba55e98c3de13824cf3d7\"\n\n[[package]]\nname = \"static_assertions\"\nversion = \"1.1.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"a2eb9349b6444b326872e140eb1cf5e7c522154d69e7a0ffb0fb81c06b37543f\"\n\n[[package]]\nname = \"strsim\"\nversion = \"0.10.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"73473c0e59e6d5812c5dfe2a064a6444949f089e20eec9a2e5506596494e4623\"\n\n[[package]]\nname = \"subtle\"\nversion = \"2.5.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"81cdd64d312baedb58e21336b31bc043b77e01cc99033ce76ef539f78e965ebc\"\n\n[[package]]\nname = \"syn\"\nversion = \"1.0.109\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"72b64191b275b66ffe2469e8af2c1cfe3bafa67b529ead792a6d0160888b4237\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"unicode-ident\",\n]\n\n[[package]]\nname = \"syn\"\nversion = \"2.0.53\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"7383cd0e49fff4b6b90ca5670bfd3e9d6a733b3f90c686605aa7eec8c4996032\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"unicode-ident\",\n]\n\n[[package]]\nname = \"synstructure\"\nversion = \"0.12.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"f36bdaa60a83aca3921b5259d5400cbf5e90fc51931376a9bd4a0eb79aa7210f\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"syn 1.0.109\",\n \"unicode-xid\",\n]\n\n[[package]]\nname = \"synstructure\"\nversion = \"0.13.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"c8af7666ab7b6390ab78131fb5b0fce11d6b7a6951602017c35fa82800708971\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"syn 2.0.53\",\n]\n\n[[package]]\nname = \"tap\"\nversion = \"1.0.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"55937e1799185b12863d447f42597ed69d9928686b8d88a1df17376a097d8369\"\n\n[[package]]\nname = \"thiserror\"\nversion = \"1.0.58\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"03468839009160513471e86a034bb2c5c0e4baae3b43f79ffc55c4a5427b3297\"\ndependencies = [\n \"thiserror-impl\",\n]\n\n[[package]]\nname = \"thiserror-impl\"\nversion = \"1.0.58\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"c61f3ba182994efc43764a46c018c347bc492c79f024e705f46567b418f6d4f7\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"syn 2.0.53\",\n]\n\n[[package]]\nname = \"toml_datetime\"\nversion = \"0.6.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"7cda73e2f1397b1262d6dfdcef8aafae14d1de7748d66822d3bfeeb6d03e5e4b\"\n\n[[package]]\nname = \"toml_edit\"\nversion = \"0.19.15\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"1b5bb770da30e5cbfde35a2d7b9b8a2c4b8ef89548a7a6aeab5c9a576e3e7421\"\ndependencies = [\n \"indexmap\",\n \"toml_datetime\",\n \"winnow\",\n]\n\n[[package]]\nname = \"toml_edit\"\nversion = \"0.20.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"396e4d48bbb2b7554c944bde63101b5ae446cff6ec4a24227428f15eb72ef338\"\ndependencies = [\n \"indexmap\",\n \"toml_datetime\",\n \"winnow\",\n]\n\n[[package]]\nname = \"typenum\"\nversion = \"1.17.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"42ff0bf0c66b8238c6f3b578df37d0b7848e55df8577b3f74f92a69acceeb825\"\n\n[[package]]\nname = \"ucd-trie\"\nversion = \"0.1.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"ed646292ffc8188ef8ea4d1e0e0150fb15a5c2e12ad9b8fc191ae7a8a7f3c4b9\"\n\n[[package]]\nname = \"uint\"\nversion = \"0.9.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"76f64bba2c53b04fcab63c01a7d7427eadc821e3bc48c34dc9ba29c501164b52\"\ndependencies = [\n \"byteorder\",\n \"crunchy\",\n \"hex\",\n \"static_assertions\",\n]\n\n[[package]]\nname = \"unicode-ident\"\nversion = \"1.0.12\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"3354b9ac3fae1ff6755cb6db53683adb661634f67557942dea4facebec0fee4b\"\n\n[[package]]\nname = \"unicode-segmentation\"\nversion = \"1.11.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"d4c87d22b6e3f4a18d4d40ef354e97c90fcb14dd91d7dc0aa9d8a1172ebf7202\"\n\n[[package]]\nname = \"unicode-xid\"\nversion = \"0.2.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"f962df74c8c05a667b5ee8bcf162993134c104e96440b663c8daa176dc772d8c\"\n\n[[package]]\nname = \"unwrap\"\nversion = \"1.2.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"7e33648dd74328e622c7be51f3b40a303c63f93e6fa5f08778b6203a4c25c20f\"\n\n[[package]]\nname = \"version_check\"\nversion = \"0.9.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"49874b5167b65d7193b8aba1567f5c7d93d001cafc34600cee003eda787e483f\"\n\n[[package]]\nname = \"wasi\"\nversion = \"0.11.0+wasi-snapshot-preview1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"9c8d87e72b64a3b4db28d11ce29237c246188f4f51057d65a7eab63b7987e423\"\n\n[[package]]\nname = \"winapi\"\nversion = \"0.3.9\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"5c839a674fcd7a98952e593242ea400abe93992746761e38641405d28b00f419\"\ndependencies = [\n \"winapi-i686-pc-windows-gnu\",\n \"winapi-x86_64-pc-windows-gnu\",\n]\n\n[[package]]\nname = \"winapi-i686-pc-windows-gnu\"\nversion = \"0.4.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6\"\n\n[[package]]\nname = \"winapi-x86_64-pc-windows-gnu\"\nversion = \"0.4.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f\"\n\n[[package]]\nname = \"winnow\"\nversion = \"0.5.40\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"f593a95398737aeed53e489c785df13f3618e41dbcd6718c6addbf1395aa6876\"\ndependencies = [\n \"memchr\",\n]\n\n[[package]]\nname = \"wyz\"\nversion = \"0.5.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"05f360fc0b24296329c78fda852a1e9ae82de9cf7b27dae4b7f62f118f77b9ed\"\ndependencies = [\n \"tap\",\n]\n\n[[package]]\nname = \"xxhash-rust\"\nversion = \"0.8.10\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"927da81e25be1e1a2901d59b81b37dd2efd1fc9c9345a55007f09bf5a2d3ee03\"\n\n[[package]]\nname = \"zeroize\"\nversion = \"1.7.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"525b4ec142c6b68a2d10f01f7bbf6755599ca3f81ea53b8431b7dd348f5fdb2d\"\ndependencies = [\n \"zeroize_derive\",\n]\n\n[[package]]\nname = \"zeroize_derive\"\nversion = \"1.4.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"ce36e65b0d2999d2aafac989fb249189a141aee1f53c612c1f37d72631959f69\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"syn 2.0.53\",\n]\n",
        "Cargo.toml":"[package]\nname = \"abax_tge\"\nversion = \"1.0.0\"\nauthors = [\"\"]\nedition = \"2021\"\n\n[dependencies]\nink = { version = \"5.0.0\", default-features = false }\n\nscale = { package = \"parity-scale-codec\", version = \"3.6.9\", default-features = false, features = [\n    \"derive\",\n    \"chain-error\",\n] }\nscale-info = { version = \"2.11\", default-features = false, features = [\n    \"derive\",\n], optional = true }\n\n# These dependencies\npendzl = { version = \"=1.0.1-v1calls\", default-features = false, features = [\n    \"psp22\",\n    \"general_vest\",\n    \"psp22_mintable\",\n    \"access_control_impl\",\n    \"set_code_hash_impl\",\n] }\n\n\nprimitive-types = { version = \"0.12.1\", default-features = false, features = [\n    \"codec\",\n] }\n\n[lib]\nname = \"abax_tge\"\npath = \"lib.rs\"\n\n\n[features]\ndefault = [\"std\"]\nstd = [\n    \"ink/std\",\n    \"scale/std\",\n    \"scale-info/std\",\n    # These dependencies\n    \"pendzl/std\",\n    \"primitive-types/std\",\n    \"primitive-types/scale-info\",\n]\nink-as-dependency = []\n\n[profile.dev]\ncodegen-units = 16\npanic = \"abort\"\nlto = false\n[profile.release]\npanic = \"abort\"\nlto = false\n",
        "constants.rs":"use pendzl::traits::Timestamp;\n\n// NUMBERS\n/// One thousand.\npub const E3_U128: u128 = 10_u128.pow(3);\n/// One million.\npub const E6_U128: u128 = 10_u128.pow(6);\n/// Hundred million.\npub const E8_U128: u128 = 10_u128.pow(8);\n/// One milliard\npub const E12_U128: u128 = 10_u128.pow(12);\n\n// TIME\n/// A duration of one hour in milliseconds.\npub const ONE_HOUR: Timestamp = 60 * 60 * 1000;\n/// A duration of one day in milliseconds.\npub const ONE_DAY: Timestamp = 24 * ONE_HOUR;\n/// A duration of one year in milliseconds.\npub const ONE_YEAR: Timestamp = 365 * ONE_DAY;\n/// A duration of the vesting period for contributors and founders - 4 years.\npub const VEST_DURATION: Timestamp = ONE_YEAR * 4;\n\n// ALLOCATION - parts of 1000\n/// A part of all tokens generated by Abax TGE Contract that is allocated to founders - 20%.\npub const PART_OF_FOUNDERS_E3: u16 = 200;\n/// A part of all tokens generated by Abax TGE Contract that is allocated to foundation - 2%.\npub const PART_OD_FOUNDATION_E3: u16 = 20;\n\n// ALLOCATION - instant release parts of 1000\n/// A part of founders allocation that is instantly released - 20%\npub const INSTANT_FOUNDERS_RELEASE_E3: u16 = 200;\n/// A part of contributors allocation that is instantly released - 40%\npub const INSTANT_CONTRIBUTOR_RELEASE_E3: u16 = 400;\n\n/// A ratio of all allocation to contributors allocation; contributors have 20% resulating in ratio 5\npub const ALL_TO_PUBLIC_RATIO: u128 = 5; // 5:1\n\n// BONUS\n/// A bonus for using a referral code - 1% (total bonus is capped at 10%)\npub const BONUS_FOR_REFERRER_USE_E3: u16 = 10;\n/// A maximal additional part received as bonus - 10%.\npub const BONUS_MAX_E3: u16 = 100;\n/// An amount of tokens that must be contributed to get a 1% contribution bonus. 1000 Tokens\npub const BONUS_DENOMINATOR: u128 = 1000 * 10_u128.pow(6);\n\n/// A part of the contribution that is additionally reserved for referrer.\npub const REWARD_FOR_REFERER_E3: u16 = 20;\n",
        "lib.rs":"// SPDX-License-Identifier: MIT\n#![cfg_attr(not(feature = \"std\"), no_std, no_main)]\n\nmod constants;\nmod modules;\n\n/// A contract repsonsible for generating the Abax Token.\n#[pendzl::implementation(AccessControl, SetCodeHash)]\n#[ink::contract]\npub mod abax_tge_contract {\n    pub use crate::{\n        constants::{\n            ALL_TO_PUBLIC_RATIO, BONUS_DENOMINATOR, BONUS_FOR_REFERRER_USE_E3, BONUS_MAX_E3,\n            E12_U128, E3_U128, E6_U128, E8_U128, INSTANT_CONTRIBUTOR_RELEASE_E3,\n            INSTANT_FOUNDERS_RELEASE_E3, PART_OD_FOUNDATION_E3, PART_OF_FOUNDERS_E3,\n            REWARD_FOR_REFERER_E3, VEST_DURATION,\n        },\n        modules::tge::{\n            errors::TGEError,\n            events::{BonusMultiplierSet, Contribution, PhaseChanged, Stakedrop},\n            storage_fields::public_contribution::PublicContributionStorage,\n            traits::{AbaxTGE, AbaxTGEView, AbaxToken, AbaxTokenRef},\n        },\n    };\n    pub use ink::{\n        codegen::{Env, TraitCallBuilder},\n        prelude::{vec, vec::Vec},\n        ToAccountId,\n    };\n    pub use pendzl::{\n        contracts::{\n            general_vest::{GeneralVest, GeneralVestRef, VestingSchedule},\n            psp22::{PSP22Ref, PSP22},\n        },\n        math::{\n            errors::MathError,\n            operations::{mul_div, Rounding},\n        },\n    };\n\n    /// A role type for access to stakedrop function - 4_193_574_647_u32.\n    pub const STAKEDROP_ADMIN: RoleType = ink::selector_id!(\"STAKEDROP_ADMIN\");\n    /// A role type for access to set_exp_bonus_multiplier_e3 function\n    pub const REFERRER_ADMIN: RoleType = ink::selector_id!(\"REFERRER_ADMIN\");\n    /// A role type for access to set_exp_bonus_multiplier_e3 function\n    pub const BONUS_ADMIN: RoleType = ink::selector_id!(\"BONUS_ADMIN\");\n\n    pub const MINIMUM_AMOUNT: Balance = 25_000_000_000_000; // 1 USDC in phase one\n\n    pub enum Generate {\n        // used to generate for referrers\n        Reserve,\n        // used to generate for contributors\n        Distribute,\n    }\n\n    #[ink(storage)]\n    #[derive(StorageFieldGetter)]\n    pub struct TGEContract {\n        #[storage_field]\n        access_control: AccessControlData,\n        #[storage_field]\n        tge: PublicContributionStorage,\n    }\n\n    impl TGEContract {\n        #[allow(clippy::too_many_arguments)]\n        #[ink(constructor)]\n        pub fn new(\n            start_time: Timestamp,\n            phase_two_duration: Timestamp,\n            generated_token_address: AccountId,\n            contribution_token_address: AccountId,\n            vester_address: AccountId,\n            founders_address: AccountId,\n            foundation_address: AccountId,\n            strategic_reserves_address: AccountId,\n            phase_one_token_cap: u128,\n            cost_to_mint_milliard_tokens: u128,\n        ) -> Self {\n            Self {\n                access_control: AccessControlData::new(Some(Self::env().caller())),\n                tge: PublicContributionStorage::new(\n                    start_time,\n                    phase_two_duration,\n                    generated_token_address,\n                    contribution_token_address,\n                    vester_address,\n                    founders_address,\n                    foundation_address,\n                    strategic_reserves_address,\n                    phase_one_token_cap,\n                    cost_to_mint_milliard_tokens,\n                ),\n            }\n        }\n    }\n\n    impl AbaxTGE for TGEContract {\n        #[ink(message)]\n        fn init(&mut self) -> Result<(), TGEError> {\n            if self.tge.total_amount_minted() > 0 {\n                return Err(TGEError::AlreadyInitialized);\n            }\n\n            self.generate_to_self(mul_div(\n                80,\n                self.tge.phase_one_token_cap,\n                100,\n                Rounding::Down,\n            )?)?;\n            self.tge.reserve_tokens(\n                self.tge.founders_address,\n                mul_div(20, self.tge.phase_one_token_cap, 100, Rounding::Down)?,\n            )?;\n            self.tge.reserve_tokens(\n                self.tge.foundation_address,\n                mul_div(2, self.tge.phase_one_token_cap, 100, Rounding::Down)?,\n            )?;\n            self.tge.reserve_tokens(\n                self.tge.strategic_reserves_address,\n                mul_div(58, self.tge.phase_one_token_cap, 100, Rounding::Down)?,\n            )?;\n            Ok(())\n        }\n\n        // creates tokens for the contributor (amount + bonus)\n        // 40% of the tokens are instantly transfered to the contributor\n        // the rest is scheduled to be vested over 4 years\n        // takes into account the exp bonus, contribution bonus and refferer bonus\n        // if refferer is passed generates tokens for the referer\n        // updates the base created and bonus created amounts\n        #[ink(message)]\n        fn contribute(\n            &mut self,\n            to_create: Balance,\n            receiver: AccountId,\n            referrer: Option<AccountId>,\n        ) -> Result<u128, TGEError> {\n            self._ensure_has_started()?;\n            self._ensure_is_not_finished()?;\n            _ensure_minimum_amount(to_create)?;\n            self._ensure_caller_is_not_contract()?;\n            self._ensure_referrer_is_registered(referrer)?;\n\n            let contributor = self.env().caller();\n\n            let cost = self.calculate_cost(to_create)?;\n\n            self.tge\n                .contribution_token\n                .call_mut()\n                .transfer_from(\n                    contributor,\n                    self.tge.strategic_reserves_address,\n                    cost,\n                    vec![],\n                )\n                .call_v1()\n                .invoke()?;\n            self.tge.increase_contributed_amount(contributor, cost)?;\n\n            let bonus = self.calculate_bonus_and_update_created_base_and_bonus(\n                contributor,\n                to_create,\n                referrer,\n            )?;\n\n            self.generate_tokens(\n                receiver,\n                to_create.checked_add(bonus).ok_or(MathError::Overflow)?,\n                Generate::Distribute,\n            )?;\n\n            if let Some(r) = referrer {\n                let referer_reward = mul_denom_e3(to_create, REWARD_FOR_REFERER_E3 as u128)?;\n                self.generate_tokens(r, referer_reward, Generate::Reserve)?;\n            }\n\n            self.env().emit_event(Contribution {\n                contributor,\n                receiver,\n                to_create,\n                referrer,\n            });\n\n            Ok(cost)\n        }\n\n        // reserves amount.checked_add(bonus).ok_or(MathError::Overflow)? of tokens for the receiver\n        // updates the contributed amount of the  by the fee_paid\n        // updates the base created and bonus created amounts\n        #[ink(message)]\n        fn stakedrop(\n            &mut self,\n            amount: Balance,\n            fee_paid: Balance,\n            receiver: AccountId,\n        ) -> Result<(), TGEError> {\n            self._ensure_has_role(STAKEDROP_ADMIN, Some(self.env().caller()))?;\n            self._ensure_has_not_started()?;\n            self.tge.increase_contributed_amount(receiver, fee_paid)?;\n\n            let bonus =\n                self.calculate_bonus_and_update_created_base_and_bonus(receiver, amount, None)?;\n\n            let amount_plus_bonus = amount.checked_add(bonus).ok_or(MathError::Overflow)?;\n            self.generate_to_self(amount_plus_bonus)?;\n            self.tge.reserve_tokens(receiver, amount_plus_bonus)?;\n\n            self.env().emit_event(Stakedrop {\n                receiver,\n                amount,\n                fee_paid,\n            });\n            Ok(())\n        }\n\n        // collects reserved tokens for the caller\n        // distributes the reserved tokens to the caller according to the rules (instnant / vesting)\n        // deletes the reserved tokens\n        #[ink(message)]\n        fn collect_reserved(&mut self, account: AccountId) -> Result<Balance, TGEError> {\n            self._ensure_has_started()?;\n\n            let reserved_amount = self.tge.collect_reserved_tokens(account)?;\n\n            if account == self.tge.strategic_reserves_address\n                || account == self.tge.foundation_address\n            {\n                self.distribute(account, reserved_amount, E3_U128 as u16)?;\n            } else if account == self.tge.founders_address {\n                self.distribute(account, reserved_amount, INSTANT_FOUNDERS_RELEASE_E3)?;\n            } else {\n                self.distribute(account, reserved_amount, INSTANT_CONTRIBUTOR_RELEASE_E3)?;\n            }\n            Ok(reserved_amount)\n        }\n\n        #[ink(message)]\n        fn set_exp_bonus_multiplier_e3(\n            &mut self,\n            contributor: AccountId,\n            bonus_multiplier_e3: u16,\n        ) -> Result<(), TGEError> {\n            self._ensure_has_role(BONUS_ADMIN, Some(self.env().caller()))?;\n            self.tge\n                .set_exp_bonus_multiplier_of_e3(&contributor, &bonus_multiplier_e3);\n            self.env().emit_event(BonusMultiplierSet {\n                account: contributor,\n                multiplier: bonus_multiplier_e3,\n            });\n            Ok(())\n        }\n\n        #[ink(message)]\n        fn register_referrer(&mut self, referrer: AccountId) -> Result<(), TGEError> {\n            self._ensure_has_role(REFERRER_ADMIN, Some(self.env().caller()))?;\n            self.tge.add_referrer(&referrer);\n            Ok(())\n        }\n    }\n\n    impl AbaxTGEView for TGEContract {\n        //returns a tuple with all of the TGE state properties that are not mappings\n        #[ink(message)]\n        fn tge_parameters(\n            &self,\n        ) -> (\n            u64,\n            Option<u64>,\n            u64,\n            AccountId,\n            AccountId,\n            AccountId,\n            AccountId,\n            AccountId,\n            AccountId,\n            u128,\n            u128,\n        ) {\n            (\n                self.tge.start_time,\n                self.tge.phase_two_start_time,\n                self.tge.phase_two_duration,\n                self.tge.generated_token_address,\n                self.tge.contribution_token.to_account_id(),\n                self.tge.vester.to_account_id(),\n                self.tge.founders_address,\n                self.tge.foundation_address,\n                self.tge.strategic_reserves_address,\n                self.tge.phase_one_token_cap,\n                self.tge.cost_to_mint_milliard_tokens,\n            )\n        }\n\n        #[ink(message)]\n        fn total_amount_minted(&self) -> Balance {\n            self.tge.total_amount_minted()\n        }\n\n        #[ink(message)]\n        fn exp_bonus_multiplier_of_e3(&self, account: AccountId) -> u16 {\n            self.tge.exp_bonus_multiplier_of_e3(&account)\n        }\n\n        #[ink(message)]\n        fn contribution_bonus_multiplier_of_e3(&self, account: AccountId) -> u16 {\n            self.get_contribution_bonus_multiplier_e3(account)\n        }\n        #[ink(message)]\n        fn is_referrer(&self, account: AccountId) -> bool {\n            self.tge.is_referrer(&account)\n        }\n\n        #[ink(message)]\n        fn reserved_for(&self, account: AccountId) -> Balance {\n            self.tge.reserved_tokens(&account)\n        }\n\n        #[ink(message)]\n        fn contributed_amount_by(&self, account: AccountId) -> Balance {\n            self.tge.contributed_amount_by(&account)\n        }\n\n        #[ink(message)]\n        fn generated_base_amount_by(&self, account: AccountId) -> Balance {\n            self.tge.base_amount_created(&account)\n        }\n\n        #[ink(message)]\n        fn generated_bonus_amount_by(&self, account: AccountId) -> Balance {\n            self.tge.bonus_amount_created(&account)\n        }\n\n        #[ink(message)]\n        fn calculate_cost(&self, to_create: Balance) -> Balance {\n            self.calculate_cost(to_create).unwrap_or(0)\n        }\n    }\n\n    fn _ensure_minimum_amount(to_create: u128) -> Result<(), TGEError> {\n        if to_create < MINIMUM_AMOUNT {\n            return Err(TGEError::AmountLessThanMinimum);\n        }\n        Ok(())\n    }\n\n    impl TGEContract {\n        fn _ensure_has_started(&self) -> Result<(), TGEError> {\n            if self.env().block_timestamp() < self.tge.start_time {\n                return Err(TGEError::TGENotStarted);\n            }\n            if self.tge.total_amount_minted() == 0 {\n                return Err(TGEError::TGENotStarted);\n            }\n            Ok(())\n        }\n\n        fn _ensure_has_not_started(&self) -> Result<(), TGEError> {\n            if self.env().block_timestamp() >= self.tge.start_time {\n                return Err(TGEError::TGEStarted);\n            }\n            Ok(())\n        }\n\n        fn _ensure_is_not_finished(&self) -> Result<(), TGEError> {\n            if let Some(phase_two_start_time) = self.tge.phase_two_start_time {\n                let phase_two_end = phase_two_start_time\n                    .checked_add(self.tge.phase_two_duration)\n                    .ok_or(MathError::Overflow)?;\n                if self.env().block_timestamp() > phase_two_end {\n                    return Err(TGEError::TGEEnded);\n                }\n            }\n            Ok(())\n        }\n\n        fn _ensure_caller_is_not_contract(&self) -> Result<(), TGEError> {\n            if self.env().is_contract(&self.env().caller()) {\n                Err(TGEError::ContributionViaContract)\n            } else {\n                Ok(())\n            }\n        }\n\n        fn _ensure_referrer_is_registered(\n            &self,\n            referrer: Option<AccountId>,\n        ) -> Result<(), TGEError> {\n            if let Some(referrer) = referrer {\n                if !self.tge.is_referrer(&referrer) {\n                    return Err(TGEError::InvalidReferrer);\n                }\n            }\n            Ok(())\n        }\n\n        fn _is_phase_one(&self) -> bool {\n            self.tge.phase_two_start_time.is_none()\n        }\n    }\n    impl TGEContract {\n        // return bonus multiplier awarded for contribution\n        fn get_contribution_bonus_multiplier_e3(&self, contributor: AccountId) -> u16 {\n            let amount_contributed = self.tge.contributed_amount_by(&contributor);\n            // if overflow happens return maximal bonus\n            u16::try_from(\n                mul_div(amount_contributed, 10, BONUS_DENOMINATOR, Rounding::Down).unwrap_or(100),\n            )\n            .unwrap_or(100)\n        }\n\n        /// returns the bonus amount of tokens based on the base_amount and zealy exp bonus, contribution bonus and refferer\n        /// updates the base amount received and the bonus amount received\n        fn calculate_bonus_and_update_created_base_and_bonus(\n            &mut self,\n            contributor: AccountId,\n            to_create: u128,\n            referrer: Option<AccountId>,\n        ) -> Result<u128, TGEError> {\n            let mut bonus_multiplier_e3 = self\n                .tge\n                .exp_bonus_multiplier_of_e3(&contributor)\n                .checked_add(self.get_contribution_bonus_multiplier_e3(contributor))\n                .ok_or(MathError::Overflow)?;\n\n            if referrer.is_some() {\n                bonus_multiplier_e3 = bonus_multiplier_e3\n                    .checked_add(BONUS_FOR_REFERRER_USE_E3)\n                    .ok_or(MathError::Overflow)?;\n            }\n\n            if bonus_multiplier_e3 > BONUS_MAX_E3 {\n                bonus_multiplier_e3 = BONUS_MAX_E3;\n            }\n\n            self.tge\n                .increase_base_amount_created(&contributor, to_create)?;\n            let received_base = self.tge.base_amount_created(&contributor);\n\n            let eligible_bonus = mul_denom_e3(received_base, bonus_multiplier_e3 as u128)?;\n            let bonus_already_received = self.tge.bonus_amount_created(&contributor);\n            // it may happen that the previously one used refferers code and now one is not using one.\n            // This may result in a bonus_already_received being greater than eligible_bonus\n            let bonus = eligible_bonus.saturating_sub(bonus_already_received);\n            self.tge\n                .increase_bonus_amount_created(&contributor, bonus)?;\n\n            Ok(bonus)\n        }\n\n        // Calculates the cost of creating tokens (doesn't include bonuses)\n        // During phase 1\n        // The cost is amount_to_create * phase_one_cost_per_milliard_tokens / 10^12\n        // During phase 2\n        // The cost is\n        // amount_to_create * effective_cost_per_milliard / 10^12\n        // where effective cost per milliard tokens is equal to the cost  before and cost after the minting\n        // the cost is given by phase_one_cost_per_milliard_tokens * (total_amount_minted * phase_one_token_cap)\n        fn calculate_cost(&self, to_create: Balance) -> Result<u128, TGEError> {\n            let mut amount_phase1 = 0;\n            let mut amount_phase2 = 0;\n            let total_amount_minted = self.tge.total_amount_minted();\n\n            if total_amount_minted >= self.tge.phase_one_token_cap {\n                amount_phase2 = to_create;\n            } else if total_amount_minted\n                .checked_add(to_create)\n                .ok_or(MathError::Overflow)?\n                <= self.tge.phase_one_token_cap\n            {\n                amount_phase1 = to_create;\n            } else {\n                amount_phase1 = self\n                    .tge\n                    .phase_one_token_cap\n                    .checked_sub(total_amount_minted)\n                    .ok_or(MathError::Underflow)?;\n                amount_phase2 = to_create\n                    .checked_sub(amount_phase1)\n                    .ok_or(MathError::Underflow)?;\n            }\n\n            let cost_phase1: Balance =\n                mul_denom_e12(amount_phase1, self.tge.cost_to_mint_milliard_tokens)?;\n\n            let cost_phase2: Balance = {\n                if amount_phase2 == 0 {\n                    0\n                } else {\n                    // take into account that during 2nd phase contributor also generates tokens to founders foundation and strategic reserves to keep 20/20/2/58 ratio.\n                    let effective_tokens = amount_phase2\n                        .checked_mul(ALL_TO_PUBLIC_RATIO)\n                        .ok_or(MathError::Overflow)?;\n\n                    let averaged_amount =\n                        if self.tge.total_amount_minted() <= self.tge.phase_one_token_cap {\n                            self.tge\n                                .phase_one_token_cap\n                                .checked_add(effective_tokens / 2)\n                                .ok_or(MathError::Overflow)?\n                        } else {\n                            self.tge\n                                .total_amount_minted()\n                                .checked_add(effective_tokens / 2)\n                                .ok_or(MathError::Overflow)?\n                        };\n\n                    let effective_cost_per_milliard = mul_div(\n                        self.tge.cost_to_mint_milliard_tokens,\n                        averaged_amount,\n                        self.tge.phase_one_token_cap,\n                        Rounding::Up,\n                    )?;\n\n                    mul_denom_e12(amount_phase2, effective_cost_per_milliard)?\n                }\n            };\n\n            Ok(cost_phase1\n                .checked_add(cost_phase2)\n                .ok_or(MathError::Overflow)?)\n        }\n\n        // Generates tokens\n        // it approperiatly distributes/resereves tokens to \"to\"\n        // if in phase_two it additionally mints tokens to self and reserves tokens for founders,foundation and strategic reserves\n        fn generate_tokens(\n            &mut self,\n            to: AccountId,\n            amount: Balance,\n            gen: Generate,\n        ) -> Result<(), TGEError> {\n            let total_amount_minted = self.tge.total_amount_minted();\n            let total_amount_minted_plus_amount = total_amount_minted\n                .checked_add(amount)\n                .ok_or(MathError::Overflow)?;\n\n            if total_amount_minted < self.tge.phase_one_token_cap\n                && total_amount_minted_plus_amount >= self.tge.phase_one_token_cap\n            {\n                self.tge.phase_two_start_time = Some(self.env().block_timestamp());\n                self.env().emit_event(PhaseChanged {});\n            }\n\n            let mut amount_phase1 = 0;\n            let mut amount_phase2 = 0;\n\n            if total_amount_minted >= self.tge.phase_one_token_cap {\n                amount_phase2 = amount;\n            } else if total_amount_minted_plus_amount <= self.tge.phase_one_token_cap {\n                amount_phase1 = amount;\n            } else {\n                amount_phase1 = self\n                    .tge\n                    .phase_one_token_cap\n                    .checked_sub(total_amount_minted)\n                    .ok_or(MathError::Underflow)?;\n                amount_phase2 = amount\n                    .checked_sub(amount_phase1)\n                    .ok_or(MathError::Underflow)?;\n            }\n\n            // in phase 2 whenever a token is generated during contribution appropariate amount of tokens is created for foundation, founders, strategic reserves to keep the 20/20/2/58 ratio.\n            let amount_to_mint_phase2 = ALL_TO_PUBLIC_RATIO\n                .checked_mul(amount_phase2)\n                .ok_or(MathError::Overflow)?;\n            let amount_to_mint = amount_phase1\n                .checked_add(amount_to_mint_phase2)\n                .ok_or(MathError::Overflow)?;\n\n            self.generate_to_self(amount_to_mint)?;\n\n            match gen {\n                Generate::Reserve => {\n                    self.tge.reserve_tokens(to, amount)?;\n                }\n                Generate::Distribute => {\n                    self.distribute(to, amount, INSTANT_CONTRIBUTOR_RELEASE_E3)?;\n                }\n            }\n\n            if amount_phase2 > 0 {\n                let founders_amount =\n                    mul_denom_e3(amount_to_mint_phase2, PART_OF_FOUNDERS_E3 as u128)?;\n                self.tge\n                    .reserve_tokens(self.tge.founders_address, founders_amount)?;\n                let foundation_amount =\n                    mul_denom_e3(amount_to_mint_phase2, PART_OD_FOUNDATION_E3 as u128)?;\n                self.tge\n                    .reserve_tokens(self.tge.foundation_address, foundation_amount)?;\n                let strategic_reserves_amount = amount_to_mint_phase2\n                    .checked_sub(\n                        founders_amount\n                            .checked_add(foundation_amount)\n                            .ok_or(MathError::Overflow)?\n                            .checked_add(amount_phase2)\n                            .ok_or(MathError::Overflow)?,\n                    )\n                    .ok_or(MathError::Underflow)?;\n                self.tge.reserve_tokens(\n                    self.tge.strategic_reserves_address,\n                    strategic_reserves_amount,\n                )?;\n            }\n\n            Ok(())\n        }\n\n        fn generate_to_self(&mut self, amount: Balance) -> Result<(), TGEError> {\n            let mut abax: AbaxTokenRef = self.tge.generated_token_address.into();\n\n            abax.call_mut()\n                .generate(self.env().account_id(), amount)\n                .call_v1()\n                .invoke()?;\n            self.tge.increase_total_amount_minted(amount)?;\n            Ok(())\n        }\n\n        /// Distributes tokens to \"to\"\n        /// instant_e3 / E3 part of the amount is instantly transfered to \"to\"\n        /// the rest is scheduled to be vested\n        fn distribute(\n            &self,\n            to: AccountId,\n            amount: Balance,\n            instant_e3: u16,\n        ) -> Result<(), TGEError> {\n            let amount_to_transfer = mul_denom_e3(amount, instant_e3 as u128)?;\n            let amount_to_vest = amount\n                .checked_sub(amount_to_transfer)\n                .ok_or(MathError::Underflow)?;\n\n            let mut psp22: PSP22Ref = self.tge.generated_token_address.into();\n            psp22\n                .call_mut()\n                .transfer(to, amount_to_transfer, Vec::<u8>::new())\n                .call_v1()\n                .invoke()?;\n\n            if amount_to_vest > 0 {\n                self.schedule_vest(to, amount_to_vest)?;\n            }\n\n            Ok(())\n        }\n\n        // creates a vesting schedule for \"to\" with \"amount\" of tokens\n        fn schedule_vest(&self, to: AccountId, amount: Balance) -> Result<(), TGEError> {\n            let mut general_vest: GeneralVestRef = self.tge.vester.to_account_id().into();\n            let mut psp22: PSP22Ref = self.tge.generated_token_address.into();\n\n            psp22\n                .call_mut()\n                .approve(self.tge.vester.to_account_id(), amount)\n                .call_v1()\n                .invoke()?;\n            general_vest\n                .call_mut()\n                .create_vest(\n                    to,\n                    Some(psp22.to_account_id()),\n                    amount,\n                    VestingSchedule::Constant(0, VEST_DURATION),\n                    vec![],\n                )\n                .call_v1()\n                .invoke()?;\n            Ok(())\n        }\n    }\n    fn mul_denom_e12(a: u128, b: u128) -> Result<u128, MathError> {\n        mul_div(a, b, E12_U128, Rounding::Down)\n    }\n\n    fn mul_denom_e3(a: u128, b: u128) -> Result<u128, MathError> {\n        mul_div(a, b, E3_U128, Rounding::Down)\n    }\n}\n",
        "modules/mod.rs":"pub mod tge;\n",
        "modules/tge/errors.rs":"use pendzl::{\n    contracts::{\n        access_control::AccessControlError, general_vest::VestingError, psp22::PSP22Error,\n    },\n    math::errors::MathError,\n};\n\n#[derive(Debug, PartialEq, Eq, scale::Encode, scale::Decode)]\n#[cfg_attr(feature = \"std\", derive(scale_info::TypeInfo))]\npub enum TGEError {\n    PSP22Error(PSP22Error),\n\n    MathError(MathError),\n    AccessControlError(AccessControlError),\n    CreateVestFailed(VestingError),\n    AmountLessThanMinimum,\n    TGENotStarted,\n    TGEStarted,\n    TGEEnded,\n    Phase1TokenCapReached,\n    ContributionViaContract,\n    InvalidReferrer,\n    NoReservedTokens,\n    AlreadyInitialized,\n}\n\nimpl From<PSP22Error> for TGEError {\n    fn from(e: PSP22Error) -> Self {\n        TGEError::PSP22Error(e)\n    }\n}\n\nimpl From<MathError> for TGEError {\n    fn from(e: MathError) -> Self {\n        TGEError::MathError(e)\n    }\n}\n\nimpl From<VestingError> for TGEError {\n    fn from(e: VestingError) -> Self {\n        TGEError::CreateVestFailed(e)\n    }\n}\n\nimpl From<AccessControlError> for TGEError {\n    fn from(error: AccessControlError) -> Self {\n        TGEError::AccessControlError(error)\n    }\n}\n",
        "modules/tge/events.rs":"pub use ink::primitives::AccountId;\npub use pendzl::traits::Balance;\n#[ink::event]\npub struct Contribution {\n    #[ink(topic)]\n    pub contributor: AccountId,\n    pub receiver: AccountId,\n    pub to_create: Balance,\n    pub referrer: Option<AccountId>,\n}\n#[ink::event]\npub struct Stakedrop {\n    #[ink(topic)]\n    pub receiver: AccountId,\n    pub amount: Balance,\n    pub fee_paid: Balance,\n}\n\n#[ink::event]\npub struct BonusMultiplierSet {\n    #[ink(topic)]\n    pub account: AccountId,\n    pub multiplier: u16,\n}\n\n#[ink::event]\npub struct PhaseChanged {}\n",
        "modules/tge/mod.rs":"pub mod errors;\npub mod events;\npub mod storage_fields;\npub mod structs;\npub mod traits;\n",
        "modules/tge/storage_fields/mod.rs":"pub mod public_contribution;\n",
        "modules/tge/storage_fields/public_contribution.rs":"use ink::storage::Mapping;\nuse pendzl::{\n    contracts::{general_vest::GeneralVestRef, psp22::PSP22Ref},\n    math::errors::MathError,\n    traits::{AccountId, Balance, Timestamp},\n};\n\nuse crate::modules::tge::errors::TGEError;\n\n#[derive(Debug)]\n#[pendzl::storage_item]\npub struct PublicContributionStorage {\n    // after thet timestamp accounts can start to contribute.\n    pub start_time: Timestamp,\n    // The timestamp at which phase one was concluded and phase two started.\n    pub phase_two_start_time: Option<Timestamp>,\n    // The duration of phase two.\n    pub phase_two_duration: Timestamp,\n    // token that is generated by the TGE.\n    pub generated_token_address: AccountId,\n    // token that is contributed by the public.\n    pub contribution_token: PSP22Ref,\n    // contract used to create vesting schedules.\n    pub vester: GeneralVestRef,\n    // account of the founders.\n    pub founders_address: AccountId,\n    // account of the foundation.\n    pub foundation_address: AccountId,\n    // account of the strategic reserves.\n    pub strategic_reserves_address: AccountId,\n\n    // total amount of tokens created in phase one and stakedrop.\n    pub phase_one_token_cap: Balance,\n    // cost to mint 1 milliard tokens (in absolute units) [ in contribution_token]\n    pub cost_to_mint_milliard_tokens: u128,\n    // total amount of distributed tokens.\n    total_amount_minted: Balance,\n    // bonus multiplier based on the Zealy EXP.\n    exp_bonus_multiplier_e3_by_address: Mapping<AccountId, u16>,\n    // amount of tokens contributed by each account.\n    contributed_amount_by_account: Mapping<AccountId, Balance>,\n    /// amount of tokens received by each account - doesnt include bonus.\n    base_created_by_account: Mapping<AccountId, Balance>,\n    /// amount of bonus tokens received by each account.\n    bonus_created_by_account: Mapping<AccountId, Balance>,\n    // reserved tokens for beneficiaries of referals / foundation / strategic reserves / founders.\n    reserved_tokens: Mapping<AccountId, Balance>,\n    // contains referrers.\n    referrers: Mapping<AccountId, ()>,\n}\n\nimpl PublicContributionStorage {\n    #[allow(clippy::too_many_arguments)]\n    pub fn new(\n        start_time: Timestamp,\n        phase_two_duration: Timestamp,\n        generated_token_address: AccountId,\n        contribution_token_address: AccountId,\n        vester_address: AccountId,\n        founders_address: AccountId,\n        foundation_address: AccountId,\n        strategic_reserves_address: AccountId,\n        phase_one_token_cap: u128,\n        cost_to_mint_milliard_tokens: u128,\n    ) -> Self {\n        Self {\n            start_time,\n            phase_two_start_time: None,\n            phase_two_duration,\n            generated_token_address,\n            contribution_token: contribution_token_address.into(),\n            vester: vester_address.into(),\n            phase_one_token_cap,\n            founders_address,\n            foundation_address,\n            strategic_reserves_address,\n            cost_to_mint_milliard_tokens,\n            total_amount_minted: 0,\n            exp_bonus_multiplier_e3_by_address: Default::default(),\n            contributed_amount_by_account: Default::default(),\n            base_created_by_account: Default::default(),\n            bonus_created_by_account: Default::default(),\n            reserved_tokens: Default::default(),\n            referrers: Default::default(),\n        }\n    }\n\n    pub fn total_amount_minted(&self) -> Balance {\n        self.total_amount_minted\n    }\n\n    pub fn increase_total_amount_minted(&mut self, amount: Balance) -> Result<(), MathError> {\n        self.total_amount_minted = self\n            .total_amount_minted\n            .checked_add(amount)\n            .ok_or(MathError::Overflow)?;\n        Ok(())\n    }\n\n    pub fn increase_base_amount_created(\n        &mut self,\n        account: &AccountId,\n        amount: Balance,\n    ) -> Result<(), MathError> {\n        let received_base_amount = self\n            .base_created_by_account\n            .get(account)\n            .unwrap_or_default();\n        self.base_created_by_account.insert(\n            account,\n            &(received_base_amount\n                .checked_add(amount)\n                .ok_or(MathError::Overflow)?),\n        );\n        Ok(())\n    }\n\n    pub fn base_amount_created(&self, account: &AccountId) -> Balance {\n        self.base_created_by_account\n            .get(account)\n            .unwrap_or_default()\n    }\n\n    pub fn increase_bonus_amount_created(\n        &mut self,\n        account: &AccountId,\n        amount: Balance,\n    ) -> Result<(), MathError> {\n        let received_bonus_amount = self\n            .bonus_created_by_account\n            .get(account)\n            .unwrap_or_default();\n        self.bonus_created_by_account.insert(\n            account,\n            &(received_bonus_amount\n                .checked_add(amount)\n                .ok_or(MathError::Overflow)?),\n        );\n        Ok(())\n    }\n\n    pub fn bonus_amount_created(&self, account: &AccountId) -> Balance {\n        self.bonus_created_by_account\n            .get(account)\n            .unwrap_or_default()\n    }\n\n    pub fn contributed_amount_by(&self, account: &AccountId) -> Balance {\n        self.contributed_amount_by_account\n            .get(account)\n            .unwrap_or_default()\n    }\n\n    pub fn increase_contributed_amount(\n        &mut self,\n        account: AccountId,\n        amount: Balance,\n    ) -> Result<(), MathError> {\n        let contributed_amount = self\n            .contributed_amount_by_account\n            .get(account)\n            .unwrap_or_default();\n        self.contributed_amount_by_account.insert(\n            account,\n            &(contributed_amount\n                .checked_add(amount)\n                .ok_or(MathError::Overflow)?),\n        );\n        Ok(())\n    }\n\n    pub fn reserved_tokens(&self, account: &AccountId) -> Balance {\n        self.reserved_tokens.get(account).unwrap_or(0)\n    }\n\n    pub fn reserve_tokens(&mut self, account: AccountId, amount: Balance) -> Result<(), MathError> {\n        let reserved_amount = self.reserved_tokens.get(account).unwrap_or_default();\n        self.reserved_tokens.insert(\n            account,\n            &(reserved_amount\n                .checked_add(amount)\n                .ok_or(MathError::Overflow)?),\n        );\n        Ok(())\n    }\n\n    pub fn collect_reserved_tokens(&mut self, account: AccountId) -> Result<Balance, TGEError> {\n        self.reserved_tokens\n            .take(account)\n            .ok_or(TGEError::NoReservedTokens)\n    }\n\n    pub fn set_exp_bonus_multiplier_of_e3(\n        &mut self,\n        account: &AccountId,\n        bonus_multiplier_e3: &u16,\n    ) {\n        self.exp_bonus_multiplier_e3_by_address\n            .insert(account, bonus_multiplier_e3);\n    }\n\n    pub fn exp_bonus_multiplier_of_e3(&self, account: &AccountId) -> u16 {\n        self.exp_bonus_multiplier_e3_by_address\n            .get(account)\n            .unwrap_or_default()\n    }\n\n    pub fn add_referrer(&mut self, account: &AccountId) {\n        self.referrers.insert(account, &());\n    }\n\n    pub fn remove_referrer(&mut self, account: &AccountId) {\n        self.referrers.take(account);\n    }\n\n    pub fn is_referrer(&self, account: &AccountId) -> bool {\n        self.referrers.contains(account)\n    }\n}\n",
        "modules/tge/structs.rs":"use pendzl::traits::Timestamp;\n\n#[derive(Debug, Copy, Clone, scale::Encode, scale::Decode)]\npub struct TokenAllocationDistribution {\n    pub public_contribution: Allocation,\n    pub founders: Allocation,\n    pub foundation: Allocation,\n    pub strategic_reserves: Allocation,\n}\n\n#[derive(Debug, Copy, Clone, scale::Encode, scale::Decode)]\npub struct Allocation {\n    pub instant_release_percentage_e3: u16,\n    pub vesting_params: Option<VestingParams>,\n}\n\n#[derive(Debug, Copy, Clone, scale::Encode, scale::Decode)]\npub struct VestingParams {\n    pub amount_to_release_percentage_e3: u16,\n    pub duration: Timestamp,\n}\n",
        "modules/tge/traits.rs":"use pendzl::{\n    contracts::psp22::PSP22Error,\n    traits::{AccountId, Balance},\n};\n\nuse crate::modules::tge::errors::TGEError;\n\n#[ink::trait_definition]\n/// Trait defining the functions for the TGE module.\npub trait AbaxTGE {\n    /// Initializes the TGE.\n    /// Reserves tokens for foundation, strategic reserves and founders.\n    ///\n    /// # Errors\n    ///\n    /// Returns \"AlreadyInitialized\" if the TGE has already been initialized.\n    #[ink(message)]\n    fn init(&mut self) -> Result<(), TGEError>;\n    /// Contribute function for the TGE module.\n    ///\n    /// # Arguments\n    ///\n    /// * `to_create` - The amount of tokens to create.\n    /// * `receiver` - The account ID of the receiver.\n    /// * `referrer` - An optional account ID of the referrer.\n    ///\n    /// # Returns\n    ///\n    /// Returns the amount of tokens created as a result of the contribution, or an error if the contribution fails.\n    #[ink(message)]\n    fn contribute(\n        &mut self,\n        to_create: Balance,\n        receiver: AccountId,\n        referrer: Option<AccountId>,\n    ) -> Result<u128, TGEError>;\n\n    /// Stakedrop function for the TGE module.\n    ///\n    /// # Arguments\n    ///\n    /// * `to_create` - The amount of tokens to create.\n    /// * `fee_paid` - The fee paid for the stakedrop.\n    /// * `receiver` - The account ID of the receiver.\n    ///\n    /// # Returns\n    ///\n    /// Returns `Ok(())` if the stakedrop is successful, or an error if the stakedrop fails.\n    #[ink(message)]\n    fn stakedrop(\n        &mut self,\n        to_create: Balance,\n        fee_paid: Balance,\n        receiver: AccountId,\n    ) -> Result<(), TGEError>;\n\n    /// Collect reserved tokens for account and distributes them to account..\n    ///\n    /// # Returns\n    ///\n    /// Returns the amount of reserved tokens collected, or an error if the collection fails.\n    #[ink(message)]\n    fn collect_reserved(&mut self, account: AccountId) -> Result<Balance, TGEError>;\n\n    #[ink(message)]\n    fn set_exp_bonus_multiplier_e3(\n        &mut self,\n        contributor: AccountId,\n        bonus_multiplier_e3: u16,\n    ) -> Result<(), TGEError>;\n\n    #[ink(message)]\n    fn register_referrer(&mut self, referrer: AccountId) -> Result<(), TGEError>;\n}\n\n#[ink::trait_definition]\npub trait AbaxTGEView {\n    #[ink(message)]\n    fn tge_parameters(\n        &self,\n    ) -> (\n        u64,\n        Option<u64>,\n        u64,\n        AccountId,\n        AccountId,\n        AccountId,\n        AccountId,\n        AccountId,\n        AccountId,\n        u128,\n        u128,\n    );\n    #[ink(message)]\n    fn total_amount_minted(&self) -> Balance;\n\n    #[ink(message)]\n    fn exp_bonus_multiplier_of_e3(&self, contributor: AccountId) -> u16;\n\n    #[ink(message)]\n    fn contribution_bonus_multiplier_of_e3(&self, contributor: AccountId) -> u16;\n\n    #[ink(message)]\n    fn is_referrer(&self, contributor: AccountId) -> bool;\n\n    #[ink(message)]\n    fn reserved_for(&self, account: AccountId) -> Balance;\n\n    #[ink(message)]\n    fn contributed_amount_by(&self, account: AccountId) -> Balance;\n\n    #[ink(message)]\n    fn generated_base_amount_by(&self, account: AccountId) -> Balance;\n\n    #[ink(message)]\n    fn generated_bonus_amount_by(&self, account: AccountId) -> Balance;\n\n    #[ink(message)]\n    fn calculate_cost(&self, to_create: Balance) -> Balance;\n}\n\nuse ink::{contract_ref, env::DefaultEnvironment};\npub type AbaxTokenRef = contract_ref!(AbaxToken, DefaultEnvironment);\n\n#[ink::trait_definition]\npub trait AbaxToken {\n    #[ink(message)]\n    fn generate(&mut self, to: AccountId, amount: Balance) -> Result<(), PSP22Error>;\n\n    #[ink(message)]\n    fn inflation_rate_per_milisecond(&self) -> Balance;\n\n    #[ink(message)]\n    fn cap(&self) -> Balance;\n}\n"
    },
    "manifest-path":"Cargo.toml"
}
